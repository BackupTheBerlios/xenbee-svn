// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_xbemsg_2eproto__INCLUDED
#define PROTOBUF_xbemsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2000003
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2000003 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>

namespace xbe {
namespace messages {

// Internal implementation detail -- do not call these.
void  protobuf_BuildDesc_xbemsg_2eproto();
void protobuf_BuildDesc_xbemsg_2eproto_AssignGlobalDescriptors(
    ::google::protobuf::FileDescriptor* file);

class XbeMessage;
class Header;
class Error;
class Task;
class Task_Env;
class Execute;
class ExecuteAck;
class ExecuteNak;
class StatusReq;
class Status;
class Finished;
class FinishedAck;
class Failed;
class FailedAck;
class Shutdown;
class ShutdownAck;
class Terminate;
class TerminateAck;
class LifeSign;

enum ErrorCode {
  UNKNOWN_ERROR = 0
};
const ::google::protobuf::EnumDescriptor* ErrorCode_descriptor();
bool ErrorCode_IsValid(int value);
const ErrorCode ErrorCode_MIN = UNKNOWN_ERROR;
const ErrorCode ErrorCode_MAX = UNKNOWN_ERROR;

enum ExecuteNakReason {
  UNKNOWN_REASON = 0,
  RESOURCE_BUSY = 1
};
const ::google::protobuf::EnumDescriptor* ExecuteNakReason_descriptor();
bool ExecuteNakReason_IsValid(int value);
const ExecuteNakReason ExecuteNakReason_MIN = UNKNOWN_REASON;
const ExecuteNakReason ExecuteNakReason_MAX = RESOURCE_BUSY;

enum StatusCode {
  IDLE = 0,
  RUNNING = 1,
  FINISHED = 2,
  FAILED = 3
};
const ::google::protobuf::EnumDescriptor* StatusCode_descriptor();
bool StatusCode_IsValid(int value);
const StatusCode StatusCode_MIN = IDLE;
const StatusCode StatusCode_MAX = FAILED;

enum FailReason {
  UNKNOWN = 0
};
const ::google::protobuf::EnumDescriptor* FailReason_descriptor();
bool FailReason_IsValid(int value);
const FailReason FailReason_MIN = UNKNOWN;
const FailReason FailReason_MAX = UNKNOWN;

// ===================================================================

class XbeMessage : public ::google::protobuf::Message {
 public:
  XbeMessage();
  virtual ~XbeMessage();
  
  XbeMessage(const XbeMessage& from);
  
  inline XbeMessage& operator=(const XbeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const XbeMessage& default_instance();
  void Swap(XbeMessage* other);
  
  // implements Message ----------------------------------------------
  
  XbeMessage* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .xbe.messages.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  inline const ::xbe::messages::Header& header() const;
  inline ::xbe::messages::Header* mutable_header();
  
  // optional .xbe.messages.Error error = 2;
  inline bool has_error() const;
  inline void clear_error();
  inline const ::xbe::messages::Error& error() const;
  inline ::xbe::messages::Error* mutable_error();
  
  // optional .xbe.messages.Execute execute = 3;
  inline bool has_execute() const;
  inline void clear_execute();
  inline const ::xbe::messages::Execute& execute() const;
  inline ::xbe::messages::Execute* mutable_execute();
  
  // optional .xbe.messages.ExecuteAck execute_ack = 4;
  inline bool has_execute_ack() const;
  inline void clear_execute_ack();
  inline const ::xbe::messages::ExecuteAck& execute_ack() const;
  inline ::xbe::messages::ExecuteAck* mutable_execute_ack();
  
  // optional .xbe.messages.ExecuteNak execute_nak = 5;
  inline bool has_execute_nak() const;
  inline void clear_execute_nak();
  inline const ::xbe::messages::ExecuteNak& execute_nak() const;
  inline ::xbe::messages::ExecuteNak* mutable_execute_nak();
  
  // optional .xbe.messages.StatusReq status_req = 6;
  inline bool has_status_req() const;
  inline void clear_status_req();
  inline const ::xbe::messages::StatusReq& status_req() const;
  inline ::xbe::messages::StatusReq* mutable_status_req();
  
  // optional .xbe.messages.Status status = 7;
  inline bool has_status() const;
  inline void clear_status();
  inline const ::xbe::messages::Status& status() const;
  inline ::xbe::messages::Status* mutable_status();
  
  // optional .xbe.messages.Finished finished = 8;
  inline bool has_finished() const;
  inline void clear_finished();
  inline const ::xbe::messages::Finished& finished() const;
  inline ::xbe::messages::Finished* mutable_finished();
  
  // optional .xbe.messages.FinishedAck finished_ack = 9;
  inline bool has_finished_ack() const;
  inline void clear_finished_ack();
  inline const ::xbe::messages::FinishedAck& finished_ack() const;
  inline ::xbe::messages::FinishedAck* mutable_finished_ack();
  
  // optional .xbe.messages.Failed failed = 10;
  inline bool has_failed() const;
  inline void clear_failed();
  inline const ::xbe::messages::Failed& failed() const;
  inline ::xbe::messages::Failed* mutable_failed();
  
  // optional .xbe.messages.FailedAck failed_ack = 11;
  inline bool has_failed_ack() const;
  inline void clear_failed_ack();
  inline const ::xbe::messages::FailedAck& failed_ack() const;
  inline ::xbe::messages::FailedAck* mutable_failed_ack();
  
  // optional .xbe.messages.Shutdown shutdown = 12;
  inline bool has_shutdown() const;
  inline void clear_shutdown();
  inline const ::xbe::messages::Shutdown& shutdown() const;
  inline ::xbe::messages::Shutdown* mutable_shutdown();
  
  // optional .xbe.messages.ShutdownAck shutdown_ack = 13;
  inline bool has_shutdown_ack() const;
  inline void clear_shutdown_ack();
  inline const ::xbe::messages::ShutdownAck& shutdown_ack() const;
  inline ::xbe::messages::ShutdownAck* mutable_shutdown_ack();
  
  // optional .xbe.messages.Terminate terminate = 14;
  inline bool has_terminate() const;
  inline void clear_terminate();
  inline const ::xbe::messages::Terminate& terminate() const;
  inline ::xbe::messages::Terminate* mutable_terminate();
  
  // optional .xbe.messages.TerminateAck terminate_ack = 15;
  inline bool has_terminate_ack() const;
  inline void clear_terminate_ack();
  inline const ::xbe::messages::TerminateAck& terminate_ack() const;
  inline ::xbe::messages::TerminateAck* mutable_terminate_ack();
  
  // optional .xbe.messages.LifeSign life_sign = 16;
  inline bool has_life_sign() const;
  inline void clear_life_sign();
  inline const ::xbe::messages::LifeSign& life_sign() const;
  inline ::xbe::messages::LifeSign* mutable_life_sign();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::xbe::messages::Header* header_;
  ::xbe::messages::Error* error_;
  ::xbe::messages::Execute* execute_;
  ::xbe::messages::ExecuteAck* execute_ack_;
  ::xbe::messages::ExecuteNak* execute_nak_;
  ::xbe::messages::StatusReq* status_req_;
  ::xbe::messages::Status* status_;
  ::xbe::messages::Finished* finished_;
  ::xbe::messages::FinishedAck* finished_ack_;
  ::xbe::messages::Failed* failed_;
  ::xbe::messages::FailedAck* failed_ack_;
  ::xbe::messages::Shutdown* shutdown_;
  ::xbe::messages::ShutdownAck* shutdown_ack_;
  ::xbe::messages::Terminate* terminate_;
  ::xbe::messages::TerminateAck* terminate_ack_;
  ::xbe::messages::LifeSign* life_sign_;
  friend void protobuf_BuildDesc_xbemsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static XbeMessage* default_instance_;
};
// -------------------------------------------------------------------

class Header : public ::google::protobuf::Message {
 public:
  Header();
  virtual ~Header();
  
  Header(const Header& from);
  
  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();
  void Swap(Header* other);
  
  // implements Message ----------------------------------------------
  
  Header* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes conversation_id = 1;
  inline bool has_conversation_id() const;
  inline void clear_conversation_id();
  inline const ::std::string& conversation_id() const;
  inline void set_conversation_id(const ::std::string& value);
  inline void set_conversation_id(const char* value);
  inline void set_conversation_id(const void* value, size_t size);
  inline ::std::string* mutable_conversation_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* conversation_id_;
  static const ::std::string _default_conversation_id_;
  friend void protobuf_BuildDesc_xbemsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Header* default_instance_;
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message {
 public:
  Error();
  virtual ~Error();
  
  Error(const Error& from);
  
  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();
  void Swap(Error* other);
  
  // implements Message ----------------------------------------------
  
  Error* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .xbe.messages.ErrorCode code = 1;
  inline bool has_code() const;
  inline void clear_code();
  inline xbe::messages::ErrorCode code() const;
  inline void set_code(xbe::messages::ErrorCode value);
  
  // optional string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline ::std::string* mutable_message();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int code_;
  ::std::string* message_;
  static const ::std::string _default_message_;
  friend void protobuf_BuildDesc_xbemsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Error* default_instance_;
};
// -------------------------------------------------------------------

class Task_Env : public ::google::protobuf::Message {
 public:
  Task_Env();
  virtual ~Task_Env();
  
  Task_Env(const Task_Env& from);
  
  inline Task_Env& operator=(const Task_Env& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Task_Env& default_instance();
  void Swap(Task_Env* other);
  
  // implements Message ----------------------------------------------
  
  Task_Env* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline ::std::string* mutable_key();
  
  // required string val = 2;
  inline bool has_val() const;
  inline void clear_val();
  inline const ::std::string& val() const;
  inline void set_val(const ::std::string& value);
  inline void set_val(const char* value);
  inline ::std::string* mutable_val();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* key_;
  static const ::std::string _default_key_;
  ::std::string* val_;
  static const ::std::string _default_val_;
  friend void protobuf_BuildDesc_xbemsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Task_Env* default_instance_;
};
// -------------------------------------------------------------------

class Task : public ::google::protobuf::Message {
 public:
  Task();
  virtual ~Task();
  
  Task(const Task& from);
  
  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Task& default_instance();
  void Swap(Task* other);
  
  // implements Message ----------------------------------------------
  
  Task* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  typedef Task_Env Env;
  
  // accessors -------------------------------------------------------
  
  // required string executable = 1;
  inline bool has_executable() const;
  inline void clear_executable();
  inline const ::std::string& executable() const;
  inline void set_executable(const ::std::string& value);
  inline void set_executable(const char* value);
  inline ::std::string* mutable_executable();
  
  // repeated string argument = 2;
  inline int argument_size() const;
  inline void clear_argument();
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& argument() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_argument();
  inline const ::std::string& argument(int index) const;
  inline ::std::string* mutable_argument(int index);
  inline void set_argument(int index, const ::std::string& value);
  inline void set_argument(int index, const char* value);
  inline ::std::string* add_argument();
  inline void add_argument(const ::std::string& value);
  inline void add_argument(const char* value);
  
  // repeated .xbe.messages.Task.Env env = 3;
  inline int env_size() const;
  inline void clear_env();
  inline const ::google::protobuf::RepeatedPtrField< ::xbe::messages::Task_Env >& env() const;
  inline ::google::protobuf::RepeatedPtrField< ::xbe::messages::Task_Env >* mutable_env();
  inline const ::xbe::messages::Task_Env& env(int index) const;
  inline ::xbe::messages::Task_Env* mutable_env(int index);
  inline ::xbe::messages::Task_Env* add_env();
  
  // optional string stdin = 6;
  inline bool has_stdin() const;
  inline void clear_stdin();
  inline const ::std::string& stdin() const;
  inline void set_stdin(const ::std::string& value);
  inline void set_stdin(const char* value);
  inline ::std::string* mutable_stdin();
  
  // optional string stdout = 7;
  inline bool has_stdout() const;
  inline void clear_stdout();
  inline const ::std::string& stdout() const;
  inline void set_stdout(const ::std::string& value);
  inline void set_stdout(const char* value);
  inline ::std::string* mutable_stdout();
  
  // optional string stderr = 8;
  inline bool has_stderr() const;
  inline void clear_stderr();
  inline const ::std::string& stderr() const;
  inline void set_stderr(const ::std::string& value);
  inline void set_stderr(const char* value);
  inline ::std::string* mutable_stderr();
  
  // optional string wd = 9 [default = "/"];
  inline bool has_wd() const;
  inline void clear_wd();
  inline const ::std::string& wd() const;
  inline void set_wd(const ::std::string& value);
  inline void set_wd(const char* value);
  inline ::std::string* mutable_wd();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* executable_;
  static const ::std::string _default_executable_;
  ::google::protobuf::RepeatedPtrField< ::std::string> argument_;
  ::google::protobuf::RepeatedPtrField< ::xbe::messages::Task_Env > env_;
  ::std::string* stdin_;
  static const ::std::string _default_stdin_;
  ::std::string* stdout_;
  static const ::std::string _default_stdout_;
  ::std::string* stderr_;
  static const ::std::string _default_stderr_;
  ::std::string* wd_;
  static const ::std::string _default_wd_;
  friend void protobuf_BuildDesc_xbemsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Task* default_instance_;
};
// -------------------------------------------------------------------

class Execute : public ::google::protobuf::Message {
 public:
  Execute();
  virtual ~Execute();
  
  Execute(const Execute& from);
  
  inline Execute& operator=(const Execute& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Execute& default_instance();
  void Swap(Execute* other);
  
  // implements Message ----------------------------------------------
  
  Execute* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .xbe.messages.Task main_task = 1;
  inline bool has_main_task() const;
  inline void clear_main_task();
  inline const ::xbe::messages::Task& main_task() const;
  inline ::xbe::messages::Task* mutable_main_task();
  
  // optional .xbe.messages.Task status_task = 2;
  inline bool has_status_task() const;
  inline void clear_status_task();
  inline const ::xbe::messages::Task& status_task() const;
  inline ::xbe::messages::Task* mutable_status_task();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::xbe::messages::Task* main_task_;
  ::xbe::messages::Task* status_task_;
  friend void protobuf_BuildDesc_xbemsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Execute* default_instance_;
};
// -------------------------------------------------------------------

class ExecuteAck : public ::google::protobuf::Message {
 public:
  ExecuteAck();
  virtual ~ExecuteAck();
  
  ExecuteAck(const ExecuteAck& from);
  
  inline ExecuteAck& operator=(const ExecuteAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecuteAck& default_instance();
  void Swap(ExecuteAck* other);
  
  // implements Message ----------------------------------------------
  
  ExecuteAck* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 task = 1;
  inline bool has_task() const;
  inline void clear_task();
  inline ::google::protobuf::int32 task() const;
  inline void set_task(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 task_;
  friend void protobuf_BuildDesc_xbemsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ExecuteAck* default_instance_;
};
// -------------------------------------------------------------------

class ExecuteNak : public ::google::protobuf::Message {
 public:
  ExecuteNak();
  virtual ~ExecuteNak();
  
  ExecuteNak(const ExecuteNak& from);
  
  inline ExecuteNak& operator=(const ExecuteNak& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecuteNak& default_instance();
  void Swap(ExecuteNak* other);
  
  // implements Message ----------------------------------------------
  
  ExecuteNak* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .xbe.messages.ExecuteNakReason reason = 1;
  inline bool has_reason() const;
  inline void clear_reason();
  inline xbe::messages::ExecuteNakReason reason() const;
  inline void set_reason(xbe::messages::ExecuteNakReason value);
  
  // optional string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline ::std::string* mutable_message();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int reason_;
  ::std::string* message_;
  static const ::std::string _default_message_;
  friend void protobuf_BuildDesc_xbemsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ExecuteNak* default_instance_;
};
// -------------------------------------------------------------------

class StatusReq : public ::google::protobuf::Message {
 public:
  StatusReq();
  virtual ~StatusReq();
  
  StatusReq(const StatusReq& from);
  
  inline StatusReq& operator=(const StatusReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusReq& default_instance();
  void Swap(StatusReq* other);
  
  // implements Message ----------------------------------------------
  
  StatusReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool execute_status_task = 1;
  inline bool has_execute_status_task() const;
  inline void clear_execute_status_task();
  inline bool execute_status_task() const;
  inline void set_execute_status_task(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  bool execute_status_task_;
  friend void protobuf_BuildDesc_xbemsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StatusReq* default_instance_;
};
// -------------------------------------------------------------------

class Status : public ::google::protobuf::Message {
 public:
  Status();
  virtual ~Status();
  
  Status(const Status& from);
  
  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Status& default_instance();
  void Swap(Status* other);
  
  // implements Message ----------------------------------------------
  
  Status* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .xbe.messages.StatusCode status = 1;
  inline bool has_status() const;
  inline void clear_status();
  inline xbe::messages::StatusCode status() const;
  inline void set_status(xbe::messages::StatusCode value);
  
  // optional int32 status_task_exit_code = 2;
  inline bool has_status_task_exit_code() const;
  inline void clear_status_task_exit_code();
  inline ::google::protobuf::int32 status_task_exit_code() const;
  inline void set_status_task_exit_code(::google::protobuf::int32 value);
  
  // optional bytes stdout = 3;
  inline bool has_stdout() const;
  inline void clear_stdout();
  inline const ::std::string& stdout() const;
  inline void set_stdout(const ::std::string& value);
  inline void set_stdout(const char* value);
  inline void set_stdout(const void* value, size_t size);
  inline ::std::string* mutable_stdout();
  
  // optional bytes stderr = 4;
  inline bool has_stderr() const;
  inline void clear_stderr();
  inline const ::std::string& stderr() const;
  inline void set_stderr(const ::std::string& value);
  inline void set_stderr(const char* value);
  inline void set_stderr(const void* value, size_t size);
  inline ::std::string* mutable_stderr();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int status_;
  ::google::protobuf::int32 status_task_exit_code_;
  ::std::string* stdout_;
  static const ::std::string _default_stdout_;
  ::std::string* stderr_;
  static const ::std::string _default_stderr_;
  friend void protobuf_BuildDesc_xbemsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Status* default_instance_;
};
// -------------------------------------------------------------------

class Finished : public ::google::protobuf::Message {
 public:
  Finished();
  virtual ~Finished();
  
  Finished(const Finished& from);
  
  inline Finished& operator=(const Finished& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Finished& default_instance();
  void Swap(Finished* other);
  
  // implements Message ----------------------------------------------
  
  Finished* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 exitcode = 1;
  inline bool has_exitcode() const;
  inline void clear_exitcode();
  inline ::google::protobuf::int32 exitcode() const;
  inline void set_exitcode(::google::protobuf::int32 value);
  
  // optional int32 task = 2;
  inline bool has_task() const;
  inline void clear_task();
  inline ::google::protobuf::int32 task() const;
  inline void set_task(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 exitcode_;
  ::google::protobuf::int32 task_;
  friend void protobuf_BuildDesc_xbemsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Finished* default_instance_;
};
// -------------------------------------------------------------------

class FinishedAck : public ::google::protobuf::Message {
 public:
  FinishedAck();
  virtual ~FinishedAck();
  
  FinishedAck(const FinishedAck& from);
  
  inline FinishedAck& operator=(const FinishedAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FinishedAck& default_instance();
  void Swap(FinishedAck* other);
  
  // implements Message ----------------------------------------------
  
  FinishedAck* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 task = 1;
  inline bool has_task() const;
  inline void clear_task();
  inline ::google::protobuf::int32 task() const;
  inline void set_task(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 task_;
  friend void protobuf_BuildDesc_xbemsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FinishedAck* default_instance_;
};
// -------------------------------------------------------------------

class Failed : public ::google::protobuf::Message {
 public:
  Failed();
  virtual ~Failed();
  
  Failed(const Failed& from);
  
  inline Failed& operator=(const Failed& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Failed& default_instance();
  void Swap(Failed* other);
  
  // implements Message ----------------------------------------------
  
  Failed* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 task = 1;
  inline bool has_task() const;
  inline void clear_task();
  inline ::google::protobuf::int32 task() const;
  inline void set_task(::google::protobuf::int32 value);
  
  // optional .xbe.messages.FailReason reason = 2;
  inline bool has_reason() const;
  inline void clear_reason();
  inline xbe::messages::FailReason reason() const;
  inline void set_reason(xbe::messages::FailReason value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 task_;
  int reason_;
  friend void protobuf_BuildDesc_xbemsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Failed* default_instance_;
};
// -------------------------------------------------------------------

class FailedAck : public ::google::protobuf::Message {
 public:
  FailedAck();
  virtual ~FailedAck();
  
  FailedAck(const FailedAck& from);
  
  inline FailedAck& operator=(const FailedAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FailedAck& default_instance();
  void Swap(FailedAck* other);
  
  // implements Message ----------------------------------------------
  
  FailedAck* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 task = 1;
  inline bool has_task() const;
  inline void clear_task();
  inline ::google::protobuf::int32 task() const;
  inline void set_task(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 task_;
  friend void protobuf_BuildDesc_xbemsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FailedAck* default_instance_;
};
// -------------------------------------------------------------------

class Shutdown : public ::google::protobuf::Message {
 public:
  Shutdown();
  virtual ~Shutdown();
  
  Shutdown(const Shutdown& from);
  
  inline Shutdown& operator=(const Shutdown& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Shutdown& default_instance();
  void Swap(Shutdown* other);
  
  // implements Message ----------------------------------------------
  
  Shutdown* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string reason = 1;
  inline bool has_reason() const;
  inline void clear_reason();
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline ::std::string* mutable_reason();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* reason_;
  static const ::std::string _default_reason_;
  friend void protobuf_BuildDesc_xbemsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Shutdown* default_instance_;
};
// -------------------------------------------------------------------

class ShutdownAck : public ::google::protobuf::Message {
 public:
  ShutdownAck();
  virtual ~ShutdownAck();
  
  ShutdownAck(const ShutdownAck& from);
  
  inline ShutdownAck& operator=(const ShutdownAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ShutdownAck& default_instance();
  void Swap(ShutdownAck* other);
  
  // implements Message ----------------------------------------------
  
  ShutdownAck* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void protobuf_BuildDesc_xbemsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ShutdownAck* default_instance_;
};
// -------------------------------------------------------------------

class Terminate : public ::google::protobuf::Message {
 public:
  Terminate();
  virtual ~Terminate();
  
  Terminate(const Terminate& from);
  
  inline Terminate& operator=(const Terminate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Terminate& default_instance();
  void Swap(Terminate* other);
  
  // implements Message ----------------------------------------------
  
  Terminate* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 task = 1;
  inline bool has_task() const;
  inline void clear_task();
  inline ::google::protobuf::int32 task() const;
  inline void set_task(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 task_;
  friend void protobuf_BuildDesc_xbemsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Terminate* default_instance_;
};
// -------------------------------------------------------------------

class TerminateAck : public ::google::protobuf::Message {
 public:
  TerminateAck();
  virtual ~TerminateAck();
  
  TerminateAck(const TerminateAck& from);
  
  inline TerminateAck& operator=(const TerminateAck& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TerminateAck& default_instance();
  void Swap(TerminateAck* other);
  
  // implements Message ----------------------------------------------
  
  TerminateAck* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 task = 1;
  inline bool has_task() const;
  inline void clear_task();
  inline ::google::protobuf::int32 task() const;
  inline void set_task(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 task_;
  friend void protobuf_BuildDesc_xbemsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TerminateAck* default_instance_;
};
// -------------------------------------------------------------------

class LifeSign : public ::google::protobuf::Message {
 public:
  LifeSign();
  virtual ~LifeSign();
  
  LifeSign(const LifeSign& from);
  
  inline LifeSign& operator=(const LifeSign& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LifeSign& default_instance();
  void Swap(LifeSign* other);
  
  // implements Message ----------------------------------------------
  
  LifeSign* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 tstamp = 1;
  inline bool has_tstamp() const;
  inline void clear_tstamp();
  inline ::google::protobuf::uint64 tstamp() const;
  inline void set_tstamp(::google::protobuf::uint64 value);
  
  // optional .xbe.messages.StatusCode status = 2;
  inline bool has_status() const;
  inline void clear_status();
  inline xbe::messages::StatusCode status() const;
  inline void set_status(xbe::messages::StatusCode value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint64 tstamp_;
  int status_;
  friend void protobuf_BuildDesc_xbemsg_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static LifeSign* default_instance_;
};
// ===================================================================


// ===================================================================


// ===================================================================

// XbeMessage

// required .xbe.messages.Header header = 1;
inline bool XbeMessage::has_header() const {
  return _has_bit(0);
}
inline void XbeMessage::clear_header() {
  if (header_ != NULL) header_->::xbe::messages::Header::Clear();
  _clear_bit(0);
}
inline const ::xbe::messages::Header& XbeMessage::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::xbe::messages::Header* XbeMessage::mutable_header() {
  _set_bit(0);
  if (header_ == NULL) header_ = new ::xbe::messages::Header;
  return header_;
}

// optional .xbe.messages.Error error = 2;
inline bool XbeMessage::has_error() const {
  return _has_bit(1);
}
inline void XbeMessage::clear_error() {
  if (error_ != NULL) error_->::xbe::messages::Error::Clear();
  _clear_bit(1);
}
inline const ::xbe::messages::Error& XbeMessage::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::xbe::messages::Error* XbeMessage::mutable_error() {
  _set_bit(1);
  if (error_ == NULL) error_ = new ::xbe::messages::Error;
  return error_;
}

// optional .xbe.messages.Execute execute = 3;
inline bool XbeMessage::has_execute() const {
  return _has_bit(2);
}
inline void XbeMessage::clear_execute() {
  if (execute_ != NULL) execute_->::xbe::messages::Execute::Clear();
  _clear_bit(2);
}
inline const ::xbe::messages::Execute& XbeMessage::execute() const {
  return execute_ != NULL ? *execute_ : *default_instance_->execute_;
}
inline ::xbe::messages::Execute* XbeMessage::mutable_execute() {
  _set_bit(2);
  if (execute_ == NULL) execute_ = new ::xbe::messages::Execute;
  return execute_;
}

// optional .xbe.messages.ExecuteAck execute_ack = 4;
inline bool XbeMessage::has_execute_ack() const {
  return _has_bit(3);
}
inline void XbeMessage::clear_execute_ack() {
  if (execute_ack_ != NULL) execute_ack_->::xbe::messages::ExecuteAck::Clear();
  _clear_bit(3);
}
inline const ::xbe::messages::ExecuteAck& XbeMessage::execute_ack() const {
  return execute_ack_ != NULL ? *execute_ack_ : *default_instance_->execute_ack_;
}
inline ::xbe::messages::ExecuteAck* XbeMessage::mutable_execute_ack() {
  _set_bit(3);
  if (execute_ack_ == NULL) execute_ack_ = new ::xbe::messages::ExecuteAck;
  return execute_ack_;
}

// optional .xbe.messages.ExecuteNak execute_nak = 5;
inline bool XbeMessage::has_execute_nak() const {
  return _has_bit(4);
}
inline void XbeMessage::clear_execute_nak() {
  if (execute_nak_ != NULL) execute_nak_->::xbe::messages::ExecuteNak::Clear();
  _clear_bit(4);
}
inline const ::xbe::messages::ExecuteNak& XbeMessage::execute_nak() const {
  return execute_nak_ != NULL ? *execute_nak_ : *default_instance_->execute_nak_;
}
inline ::xbe::messages::ExecuteNak* XbeMessage::mutable_execute_nak() {
  _set_bit(4);
  if (execute_nak_ == NULL) execute_nak_ = new ::xbe::messages::ExecuteNak;
  return execute_nak_;
}

// optional .xbe.messages.StatusReq status_req = 6;
inline bool XbeMessage::has_status_req() const {
  return _has_bit(5);
}
inline void XbeMessage::clear_status_req() {
  if (status_req_ != NULL) status_req_->::xbe::messages::StatusReq::Clear();
  _clear_bit(5);
}
inline const ::xbe::messages::StatusReq& XbeMessage::status_req() const {
  return status_req_ != NULL ? *status_req_ : *default_instance_->status_req_;
}
inline ::xbe::messages::StatusReq* XbeMessage::mutable_status_req() {
  _set_bit(5);
  if (status_req_ == NULL) status_req_ = new ::xbe::messages::StatusReq;
  return status_req_;
}

// optional .xbe.messages.Status status = 7;
inline bool XbeMessage::has_status() const {
  return _has_bit(6);
}
inline void XbeMessage::clear_status() {
  if (status_ != NULL) status_->::xbe::messages::Status::Clear();
  _clear_bit(6);
}
inline const ::xbe::messages::Status& XbeMessage::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::xbe::messages::Status* XbeMessage::mutable_status() {
  _set_bit(6);
  if (status_ == NULL) status_ = new ::xbe::messages::Status;
  return status_;
}

// optional .xbe.messages.Finished finished = 8;
inline bool XbeMessage::has_finished() const {
  return _has_bit(7);
}
inline void XbeMessage::clear_finished() {
  if (finished_ != NULL) finished_->::xbe::messages::Finished::Clear();
  _clear_bit(7);
}
inline const ::xbe::messages::Finished& XbeMessage::finished() const {
  return finished_ != NULL ? *finished_ : *default_instance_->finished_;
}
inline ::xbe::messages::Finished* XbeMessage::mutable_finished() {
  _set_bit(7);
  if (finished_ == NULL) finished_ = new ::xbe::messages::Finished;
  return finished_;
}

// optional .xbe.messages.FinishedAck finished_ack = 9;
inline bool XbeMessage::has_finished_ack() const {
  return _has_bit(8);
}
inline void XbeMessage::clear_finished_ack() {
  if (finished_ack_ != NULL) finished_ack_->::xbe::messages::FinishedAck::Clear();
  _clear_bit(8);
}
inline const ::xbe::messages::FinishedAck& XbeMessage::finished_ack() const {
  return finished_ack_ != NULL ? *finished_ack_ : *default_instance_->finished_ack_;
}
inline ::xbe::messages::FinishedAck* XbeMessage::mutable_finished_ack() {
  _set_bit(8);
  if (finished_ack_ == NULL) finished_ack_ = new ::xbe::messages::FinishedAck;
  return finished_ack_;
}

// optional .xbe.messages.Failed failed = 10;
inline bool XbeMessage::has_failed() const {
  return _has_bit(9);
}
inline void XbeMessage::clear_failed() {
  if (failed_ != NULL) failed_->::xbe::messages::Failed::Clear();
  _clear_bit(9);
}
inline const ::xbe::messages::Failed& XbeMessage::failed() const {
  return failed_ != NULL ? *failed_ : *default_instance_->failed_;
}
inline ::xbe::messages::Failed* XbeMessage::mutable_failed() {
  _set_bit(9);
  if (failed_ == NULL) failed_ = new ::xbe::messages::Failed;
  return failed_;
}

// optional .xbe.messages.FailedAck failed_ack = 11;
inline bool XbeMessage::has_failed_ack() const {
  return _has_bit(10);
}
inline void XbeMessage::clear_failed_ack() {
  if (failed_ack_ != NULL) failed_ack_->::xbe::messages::FailedAck::Clear();
  _clear_bit(10);
}
inline const ::xbe::messages::FailedAck& XbeMessage::failed_ack() const {
  return failed_ack_ != NULL ? *failed_ack_ : *default_instance_->failed_ack_;
}
inline ::xbe::messages::FailedAck* XbeMessage::mutable_failed_ack() {
  _set_bit(10);
  if (failed_ack_ == NULL) failed_ack_ = new ::xbe::messages::FailedAck;
  return failed_ack_;
}

// optional .xbe.messages.Shutdown shutdown = 12;
inline bool XbeMessage::has_shutdown() const {
  return _has_bit(11);
}
inline void XbeMessage::clear_shutdown() {
  if (shutdown_ != NULL) shutdown_->::xbe::messages::Shutdown::Clear();
  _clear_bit(11);
}
inline const ::xbe::messages::Shutdown& XbeMessage::shutdown() const {
  return shutdown_ != NULL ? *shutdown_ : *default_instance_->shutdown_;
}
inline ::xbe::messages::Shutdown* XbeMessage::mutable_shutdown() {
  _set_bit(11);
  if (shutdown_ == NULL) shutdown_ = new ::xbe::messages::Shutdown;
  return shutdown_;
}

// optional .xbe.messages.ShutdownAck shutdown_ack = 13;
inline bool XbeMessage::has_shutdown_ack() const {
  return _has_bit(12);
}
inline void XbeMessage::clear_shutdown_ack() {
  if (shutdown_ack_ != NULL) shutdown_ack_->::xbe::messages::ShutdownAck::Clear();
  _clear_bit(12);
}
inline const ::xbe::messages::ShutdownAck& XbeMessage::shutdown_ack() const {
  return shutdown_ack_ != NULL ? *shutdown_ack_ : *default_instance_->shutdown_ack_;
}
inline ::xbe::messages::ShutdownAck* XbeMessage::mutable_shutdown_ack() {
  _set_bit(12);
  if (shutdown_ack_ == NULL) shutdown_ack_ = new ::xbe::messages::ShutdownAck;
  return shutdown_ack_;
}

// optional .xbe.messages.Terminate terminate = 14;
inline bool XbeMessage::has_terminate() const {
  return _has_bit(13);
}
inline void XbeMessage::clear_terminate() {
  if (terminate_ != NULL) terminate_->::xbe::messages::Terminate::Clear();
  _clear_bit(13);
}
inline const ::xbe::messages::Terminate& XbeMessage::terminate() const {
  return terminate_ != NULL ? *terminate_ : *default_instance_->terminate_;
}
inline ::xbe::messages::Terminate* XbeMessage::mutable_terminate() {
  _set_bit(13);
  if (terminate_ == NULL) terminate_ = new ::xbe::messages::Terminate;
  return terminate_;
}

// optional .xbe.messages.TerminateAck terminate_ack = 15;
inline bool XbeMessage::has_terminate_ack() const {
  return _has_bit(14);
}
inline void XbeMessage::clear_terminate_ack() {
  if (terminate_ack_ != NULL) terminate_ack_->::xbe::messages::TerminateAck::Clear();
  _clear_bit(14);
}
inline const ::xbe::messages::TerminateAck& XbeMessage::terminate_ack() const {
  return terminate_ack_ != NULL ? *terminate_ack_ : *default_instance_->terminate_ack_;
}
inline ::xbe::messages::TerminateAck* XbeMessage::mutable_terminate_ack() {
  _set_bit(14);
  if (terminate_ack_ == NULL) terminate_ack_ = new ::xbe::messages::TerminateAck;
  return terminate_ack_;
}

// optional .xbe.messages.LifeSign life_sign = 16;
inline bool XbeMessage::has_life_sign() const {
  return _has_bit(15);
}
inline void XbeMessage::clear_life_sign() {
  if (life_sign_ != NULL) life_sign_->::xbe::messages::LifeSign::Clear();
  _clear_bit(15);
}
inline const ::xbe::messages::LifeSign& XbeMessage::life_sign() const {
  return life_sign_ != NULL ? *life_sign_ : *default_instance_->life_sign_;
}
inline ::xbe::messages::LifeSign* XbeMessage::mutable_life_sign() {
  _set_bit(15);
  if (life_sign_ == NULL) life_sign_ = new ::xbe::messages::LifeSign;
  return life_sign_;
}

// -------------------------------------------------------------------

// Header

// required bytes conversation_id = 1;
inline bool Header::has_conversation_id() const {
  return _has_bit(0);
}
inline void Header::clear_conversation_id() {
  if (conversation_id_ != &_default_conversation_id_) {
    conversation_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Header::conversation_id() const {
  return *conversation_id_;
}
inline void Header::set_conversation_id(const ::std::string& value) {
  _set_bit(0);
  if (conversation_id_ == &_default_conversation_id_) {
    conversation_id_ = new ::std::string;
  }
  conversation_id_->assign(value);
}
inline void Header::set_conversation_id(const char* value) {
  _set_bit(0);
  if (conversation_id_ == &_default_conversation_id_) {
    conversation_id_ = new ::std::string;
  }
  conversation_id_->assign(value);
}
inline void Header::set_conversation_id(const void* value, size_t size) {
  _set_bit(0);
  if (conversation_id_ == &_default_conversation_id_) {
    conversation_id_ = new ::std::string;
  }
  conversation_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Header::mutable_conversation_id() {
  _set_bit(0);
  if (conversation_id_ == &_default_conversation_id_) {
    conversation_id_ = new ::std::string;
  }
  return conversation_id_;
}

// -------------------------------------------------------------------

// Error

// required .xbe.messages.ErrorCode code = 1;
inline bool Error::has_code() const {
  return _has_bit(0);
}
inline void Error::clear_code() {
  code_ = 0;
  _clear_bit(0);
}
inline xbe::messages::ErrorCode Error::code() const {
  return static_cast< xbe::messages::ErrorCode >(code_);
}
inline void Error::set_code(xbe::messages::ErrorCode value) {
  GOOGLE_DCHECK(xbe::messages::ErrorCode_IsValid(value));
  _set_bit(0);
  code_ = value;
}

// optional string message = 2;
inline bool Error::has_message() const {
  return _has_bit(1);
}
inline void Error::clear_message() {
  if (message_ != &_default_message_) {
    message_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Error::message() const {
  return *message_;
}
inline void Error::set_message(const ::std::string& value) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Error::set_message(const char* value) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline ::std::string* Error::mutable_message() {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  return message_;
}

// -------------------------------------------------------------------

// Task_Env

// required string key = 1;
inline bool Task_Env::has_key() const {
  return _has_bit(0);
}
inline void Task_Env::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Task_Env::key() const {
  return *key_;
}
inline void Task_Env::set_key(const ::std::string& value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Task_Env::set_key(const char* value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline ::std::string* Task_Env::mutable_key() {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// required string val = 2;
inline bool Task_Env::has_val() const {
  return _has_bit(1);
}
inline void Task_Env::clear_val() {
  if (val_ != &_default_val_) {
    val_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Task_Env::val() const {
  return *val_;
}
inline void Task_Env::set_val(const ::std::string& value) {
  _set_bit(1);
  if (val_ == &_default_val_) {
    val_ = new ::std::string;
  }
  val_->assign(value);
}
inline void Task_Env::set_val(const char* value) {
  _set_bit(1);
  if (val_ == &_default_val_) {
    val_ = new ::std::string;
  }
  val_->assign(value);
}
inline ::std::string* Task_Env::mutable_val() {
  _set_bit(1);
  if (val_ == &_default_val_) {
    val_ = new ::std::string;
  }
  return val_;
}

// -------------------------------------------------------------------

// Task

// required string executable = 1;
inline bool Task::has_executable() const {
  return _has_bit(0);
}
inline void Task::clear_executable() {
  if (executable_ != &_default_executable_) {
    executable_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Task::executable() const {
  return *executable_;
}
inline void Task::set_executable(const ::std::string& value) {
  _set_bit(0);
  if (executable_ == &_default_executable_) {
    executable_ = new ::std::string;
  }
  executable_->assign(value);
}
inline void Task::set_executable(const char* value) {
  _set_bit(0);
  if (executable_ == &_default_executable_) {
    executable_ = new ::std::string;
  }
  executable_->assign(value);
}
inline ::std::string* Task::mutable_executable() {
  _set_bit(0);
  if (executable_ == &_default_executable_) {
    executable_ = new ::std::string;
  }
  return executable_;
}

// repeated string argument = 2;
inline int Task::argument_size() const {
  return argument_.size();
}
inline void Task::clear_argument() {
  argument_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Task::argument() const {
  return argument_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Task::mutable_argument() {
  return &argument_;
}
inline const ::std::string& Task::argument(int index) const {
  return argument_.Get(index);
}
inline ::std::string* Task::mutable_argument(int index) {
  return argument_.Mutable(index);
}
inline void Task::set_argument(int index, const ::std::string& value) {
  argument_.Mutable(index)->assign(value);
}
inline void Task::set_argument(int index, const char* value) {
  argument_.Mutable(index)->assign(value);
}
inline ::std::string* Task::add_argument() {
  return argument_.Add();
}
inline void Task::add_argument(const ::std::string& value) {
  argument_.Add()->assign(value);
}
inline void Task::add_argument(const char* value) {
  argument_.Add()->assign(value);
}

// repeated .xbe.messages.Task.Env env = 3;
inline int Task::env_size() const {
  return env_.size();
}
inline void Task::clear_env() {
  env_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::xbe::messages::Task_Env >&
Task::env() const {
  return env_;
}
inline ::google::protobuf::RepeatedPtrField< ::xbe::messages::Task_Env >*
Task::mutable_env() {
  return &env_;
}
inline const ::xbe::messages::Task_Env& Task::env(int index) const {
  return env_.Get(index);
}
inline ::xbe::messages::Task_Env* Task::mutable_env(int index) {
  return env_.Mutable(index);
}
inline ::xbe::messages::Task_Env* Task::add_env() {
  return env_.Add();
}

// optional string stdin = 6;
inline bool Task::has_stdin() const {
  return _has_bit(3);
}
inline void Task::clear_stdin() {
  if (stdin_ != &_default_stdin_) {
    stdin_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Task::stdin() const {
  return *stdin_;
}
inline void Task::set_stdin(const ::std::string& value) {
  _set_bit(3);
  if (stdin_ == &_default_stdin_) {
    stdin_ = new ::std::string;
  }
  stdin_->assign(value);
}
inline void Task::set_stdin(const char* value) {
  _set_bit(3);
  if (stdin_ == &_default_stdin_) {
    stdin_ = new ::std::string;
  }
  stdin_->assign(value);
}
inline ::std::string* Task::mutable_stdin() {
  _set_bit(3);
  if (stdin_ == &_default_stdin_) {
    stdin_ = new ::std::string;
  }
  return stdin_;
}

// optional string stdout = 7;
inline bool Task::has_stdout() const {
  return _has_bit(4);
}
inline void Task::clear_stdout() {
  if (stdout_ != &_default_stdout_) {
    stdout_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& Task::stdout() const {
  return *stdout_;
}
inline void Task::set_stdout(const ::std::string& value) {
  _set_bit(4);
  if (stdout_ == &_default_stdout_) {
    stdout_ = new ::std::string;
  }
  stdout_->assign(value);
}
inline void Task::set_stdout(const char* value) {
  _set_bit(4);
  if (stdout_ == &_default_stdout_) {
    stdout_ = new ::std::string;
  }
  stdout_->assign(value);
}
inline ::std::string* Task::mutable_stdout() {
  _set_bit(4);
  if (stdout_ == &_default_stdout_) {
    stdout_ = new ::std::string;
  }
  return stdout_;
}

// optional string stderr = 8;
inline bool Task::has_stderr() const {
  return _has_bit(5);
}
inline void Task::clear_stderr() {
  if (stderr_ != &_default_stderr_) {
    stderr_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& Task::stderr() const {
  return *stderr_;
}
inline void Task::set_stderr(const ::std::string& value) {
  _set_bit(5);
  if (stderr_ == &_default_stderr_) {
    stderr_ = new ::std::string;
  }
  stderr_->assign(value);
}
inline void Task::set_stderr(const char* value) {
  _set_bit(5);
  if (stderr_ == &_default_stderr_) {
    stderr_ = new ::std::string;
  }
  stderr_->assign(value);
}
inline ::std::string* Task::mutable_stderr() {
  _set_bit(5);
  if (stderr_ == &_default_stderr_) {
    stderr_ = new ::std::string;
  }
  return stderr_;
}

// optional string wd = 9 [default = "/"];
inline bool Task::has_wd() const {
  return _has_bit(6);
}
inline void Task::clear_wd() {
  if (wd_ != &_default_wd_) {
    wd_->assign(_default_wd_);
  }
  _clear_bit(6);
}
inline const ::std::string& Task::wd() const {
  return *wd_;
}
inline void Task::set_wd(const ::std::string& value) {
  _set_bit(6);
  if (wd_ == &_default_wd_) {
    wd_ = new ::std::string;
  }
  wd_->assign(value);
}
inline void Task::set_wd(const char* value) {
  _set_bit(6);
  if (wd_ == &_default_wd_) {
    wd_ = new ::std::string;
  }
  wd_->assign(value);
}
inline ::std::string* Task::mutable_wd() {
  _set_bit(6);
  if (wd_ == &_default_wd_) {
    wd_ = new ::std::string(_default_wd_);
  }
  return wd_;
}

// -------------------------------------------------------------------

// Execute

// optional .xbe.messages.Task main_task = 1;
inline bool Execute::has_main_task() const {
  return _has_bit(0);
}
inline void Execute::clear_main_task() {
  if (main_task_ != NULL) main_task_->::xbe::messages::Task::Clear();
  _clear_bit(0);
}
inline const ::xbe::messages::Task& Execute::main_task() const {
  return main_task_ != NULL ? *main_task_ : *default_instance_->main_task_;
}
inline ::xbe::messages::Task* Execute::mutable_main_task() {
  _set_bit(0);
  if (main_task_ == NULL) main_task_ = new ::xbe::messages::Task;
  return main_task_;
}

// optional .xbe.messages.Task status_task = 2;
inline bool Execute::has_status_task() const {
  return _has_bit(1);
}
inline void Execute::clear_status_task() {
  if (status_task_ != NULL) status_task_->::xbe::messages::Task::Clear();
  _clear_bit(1);
}
inline const ::xbe::messages::Task& Execute::status_task() const {
  return status_task_ != NULL ? *status_task_ : *default_instance_->status_task_;
}
inline ::xbe::messages::Task* Execute::mutable_status_task() {
  _set_bit(1);
  if (status_task_ == NULL) status_task_ = new ::xbe::messages::Task;
  return status_task_;
}

// -------------------------------------------------------------------

// ExecuteAck

// optional int32 task = 1;
inline bool ExecuteAck::has_task() const {
  return _has_bit(0);
}
inline void ExecuteAck::clear_task() {
  task_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 ExecuteAck::task() const {
  return task_;
}
inline void ExecuteAck::set_task(::google::protobuf::int32 value) {
  _set_bit(0);
  task_ = value;
}

// -------------------------------------------------------------------

// ExecuteNak

// required .xbe.messages.ExecuteNakReason reason = 1;
inline bool ExecuteNak::has_reason() const {
  return _has_bit(0);
}
inline void ExecuteNak::clear_reason() {
  reason_ = 0;
  _clear_bit(0);
}
inline xbe::messages::ExecuteNakReason ExecuteNak::reason() const {
  return static_cast< xbe::messages::ExecuteNakReason >(reason_);
}
inline void ExecuteNak::set_reason(xbe::messages::ExecuteNakReason value) {
  GOOGLE_DCHECK(xbe::messages::ExecuteNakReason_IsValid(value));
  _set_bit(0);
  reason_ = value;
}

// optional string message = 2;
inline bool ExecuteNak::has_message() const {
  return _has_bit(1);
}
inline void ExecuteNak::clear_message() {
  if (message_ != &_default_message_) {
    message_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& ExecuteNak::message() const {
  return *message_;
}
inline void ExecuteNak::set_message(const ::std::string& value) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ExecuteNak::set_message(const char* value) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline ::std::string* ExecuteNak::mutable_message() {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  return message_;
}

// -------------------------------------------------------------------

// StatusReq

// optional bool execute_status_task = 1;
inline bool StatusReq::has_execute_status_task() const {
  return _has_bit(0);
}
inline void StatusReq::clear_execute_status_task() {
  execute_status_task_ = false;
  _clear_bit(0);
}
inline bool StatusReq::execute_status_task() const {
  return execute_status_task_;
}
inline void StatusReq::set_execute_status_task(bool value) {
  _set_bit(0);
  execute_status_task_ = value;
}

// -------------------------------------------------------------------

// Status

// required .xbe.messages.StatusCode status = 1;
inline bool Status::has_status() const {
  return _has_bit(0);
}
inline void Status::clear_status() {
  status_ = 0;
  _clear_bit(0);
}
inline xbe::messages::StatusCode Status::status() const {
  return static_cast< xbe::messages::StatusCode >(status_);
}
inline void Status::set_status(xbe::messages::StatusCode value) {
  GOOGLE_DCHECK(xbe::messages::StatusCode_IsValid(value));
  _set_bit(0);
  status_ = value;
}

// optional int32 status_task_exit_code = 2;
inline bool Status::has_status_task_exit_code() const {
  return _has_bit(1);
}
inline void Status::clear_status_task_exit_code() {
  status_task_exit_code_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 Status::status_task_exit_code() const {
  return status_task_exit_code_;
}
inline void Status::set_status_task_exit_code(::google::protobuf::int32 value) {
  _set_bit(1);
  status_task_exit_code_ = value;
}

// optional bytes stdout = 3;
inline bool Status::has_stdout() const {
  return _has_bit(2);
}
inline void Status::clear_stdout() {
  if (stdout_ != &_default_stdout_) {
    stdout_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Status::stdout() const {
  return *stdout_;
}
inline void Status::set_stdout(const ::std::string& value) {
  _set_bit(2);
  if (stdout_ == &_default_stdout_) {
    stdout_ = new ::std::string;
  }
  stdout_->assign(value);
}
inline void Status::set_stdout(const char* value) {
  _set_bit(2);
  if (stdout_ == &_default_stdout_) {
    stdout_ = new ::std::string;
  }
  stdout_->assign(value);
}
inline void Status::set_stdout(const void* value, size_t size) {
  _set_bit(2);
  if (stdout_ == &_default_stdout_) {
    stdout_ = new ::std::string;
  }
  stdout_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Status::mutable_stdout() {
  _set_bit(2);
  if (stdout_ == &_default_stdout_) {
    stdout_ = new ::std::string;
  }
  return stdout_;
}

// optional bytes stderr = 4;
inline bool Status::has_stderr() const {
  return _has_bit(3);
}
inline void Status::clear_stderr() {
  if (stderr_ != &_default_stderr_) {
    stderr_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Status::stderr() const {
  return *stderr_;
}
inline void Status::set_stderr(const ::std::string& value) {
  _set_bit(3);
  if (stderr_ == &_default_stderr_) {
    stderr_ = new ::std::string;
  }
  stderr_->assign(value);
}
inline void Status::set_stderr(const char* value) {
  _set_bit(3);
  if (stderr_ == &_default_stderr_) {
    stderr_ = new ::std::string;
  }
  stderr_->assign(value);
}
inline void Status::set_stderr(const void* value, size_t size) {
  _set_bit(3);
  if (stderr_ == &_default_stderr_) {
    stderr_ = new ::std::string;
  }
  stderr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Status::mutable_stderr() {
  _set_bit(3);
  if (stderr_ == &_default_stderr_) {
    stderr_ = new ::std::string;
  }
  return stderr_;
}

// -------------------------------------------------------------------

// Finished

// required int32 exitcode = 1;
inline bool Finished::has_exitcode() const {
  return _has_bit(0);
}
inline void Finished::clear_exitcode() {
  exitcode_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 Finished::exitcode() const {
  return exitcode_;
}
inline void Finished::set_exitcode(::google::protobuf::int32 value) {
  _set_bit(0);
  exitcode_ = value;
}

// optional int32 task = 2;
inline bool Finished::has_task() const {
  return _has_bit(1);
}
inline void Finished::clear_task() {
  task_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 Finished::task() const {
  return task_;
}
inline void Finished::set_task(::google::protobuf::int32 value) {
  _set_bit(1);
  task_ = value;
}

// -------------------------------------------------------------------

// FinishedAck

// optional int32 task = 1;
inline bool FinishedAck::has_task() const {
  return _has_bit(0);
}
inline void FinishedAck::clear_task() {
  task_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 FinishedAck::task() const {
  return task_;
}
inline void FinishedAck::set_task(::google::protobuf::int32 value) {
  _set_bit(0);
  task_ = value;
}

// -------------------------------------------------------------------

// Failed

// optional int32 task = 1;
inline bool Failed::has_task() const {
  return _has_bit(0);
}
inline void Failed::clear_task() {
  task_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 Failed::task() const {
  return task_;
}
inline void Failed::set_task(::google::protobuf::int32 value) {
  _set_bit(0);
  task_ = value;
}

// optional .xbe.messages.FailReason reason = 2;
inline bool Failed::has_reason() const {
  return _has_bit(1);
}
inline void Failed::clear_reason() {
  reason_ = 0;
  _clear_bit(1);
}
inline xbe::messages::FailReason Failed::reason() const {
  return static_cast< xbe::messages::FailReason >(reason_);
}
inline void Failed::set_reason(xbe::messages::FailReason value) {
  GOOGLE_DCHECK(xbe::messages::FailReason_IsValid(value));
  _set_bit(1);
  reason_ = value;
}

// -------------------------------------------------------------------

// FailedAck

// optional int32 task = 1;
inline bool FailedAck::has_task() const {
  return _has_bit(0);
}
inline void FailedAck::clear_task() {
  task_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 FailedAck::task() const {
  return task_;
}
inline void FailedAck::set_task(::google::protobuf::int32 value) {
  _set_bit(0);
  task_ = value;
}

// -------------------------------------------------------------------

// Shutdown

// optional string reason = 1;
inline bool Shutdown::has_reason() const {
  return _has_bit(0);
}
inline void Shutdown::clear_reason() {
  if (reason_ != &_default_reason_) {
    reason_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Shutdown::reason() const {
  return *reason_;
}
inline void Shutdown::set_reason(const ::std::string& value) {
  _set_bit(0);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void Shutdown::set_reason(const char* value) {
  _set_bit(0);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline ::std::string* Shutdown::mutable_reason() {
  _set_bit(0);
  if (reason_ == &_default_reason_) {
    reason_ = new ::std::string;
  }
  return reason_;
}

// -------------------------------------------------------------------

// ShutdownAck

// -------------------------------------------------------------------

// Terminate

// optional int32 task = 1;
inline bool Terminate::has_task() const {
  return _has_bit(0);
}
inline void Terminate::clear_task() {
  task_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 Terminate::task() const {
  return task_;
}
inline void Terminate::set_task(::google::protobuf::int32 value) {
  _set_bit(0);
  task_ = value;
}

// -------------------------------------------------------------------

// TerminateAck

// optional int32 task = 1;
inline bool TerminateAck::has_task() const {
  return _has_bit(0);
}
inline void TerminateAck::clear_task() {
  task_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 TerminateAck::task() const {
  return task_;
}
inline void TerminateAck::set_task(::google::protobuf::int32 value) {
  _set_bit(0);
  task_ = value;
}

// -------------------------------------------------------------------

// LifeSign

// required uint64 tstamp = 1;
inline bool LifeSign::has_tstamp() const {
  return _has_bit(0);
}
inline void LifeSign::clear_tstamp() {
  tstamp_ = GOOGLE_ULONGLONG(0);
  _clear_bit(0);
}
inline ::google::protobuf::uint64 LifeSign::tstamp() const {
  return tstamp_;
}
inline void LifeSign::set_tstamp(::google::protobuf::uint64 value) {
  _set_bit(0);
  tstamp_ = value;
}

// optional .xbe.messages.StatusCode status = 2;
inline bool LifeSign::has_status() const {
  return _has_bit(1);
}
inline void LifeSign::clear_status() {
  status_ = 0;
  _clear_bit(1);
}
inline xbe::messages::StatusCode LifeSign::status() const {
  return static_cast< xbe::messages::StatusCode >(status_);
}
inline void LifeSign::set_status(xbe::messages::StatusCode value) {
  GOOGLE_DCHECK(xbe::messages::StatusCode_IsValid(value));
  _set_bit(1);
  status_ = value;
}


}  // namespace messages
}  // namespace xbe
#endif  // PROTOBUF_xbemsg_2eproto__INCLUDED
