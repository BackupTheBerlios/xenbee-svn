#define CHAN_SIZE 1
#define MAX_RETRIES 5

mtype = {LifeSign, Execute, ExecuteAck, ExecuteNAck, Terminate, TerminateAck, Finished, FinishedAck, StatusReq, Status, Start, Shutdown, ShutdownAck};

byte done = 0;

/* define outcomes */
bit InstExecutedJob = false;
bit XbedSentJob = false;
bit InstFailed = false;

proctype Inst(chan in, out)
{
    byte retryCount = 0;

StIdle:
    /* accept new jobs, status requests and send life signals,
       it is also possible to get terminate messages that are
       handled as no ops */
    printf("inst: state idle\n");
    if
        :: in ? Execute -> printf("inst: got execute request\n"); out ! ExecuteAck; goto StBusy;
        :: in ? Shutdown -> printf("inst: got shutdown request\n"); out ! ShutdownAck; goto StTerminated;
        :: timeout -> goto StFailed;
    fi;

WaitForFinishedAck:
    if
    :: in ? FinishedAck -> goto StIdle;
    :: timeout ->
        do
        :: (retryCount < MAX_RETRIES) ->
progress_finished:
            out ! Finished;
        :: else ->
            goto StFailed;
        od;
    fi;

StBusy:
    printf("inst: state busy\n");
    if
        :: in ? Shutdown -> printf("inst: got shutdown request\n"); out ! ShutdownAck; goto StTerminated;
        /* spontaneously mark the job as finished */
        :: true -> out ! Finished; printf("inst: execution finished\n"); goto WaitForFinishedAck;
        :: true -> goto StBusy;
    fi;

StFailed:
StTerminated:
end:
    atomic { done = done + 1; }
    printf("inst: done\n");
}

proctype Xbed(chan in, out)
{
    byte retryCounter = 0;

StIdle:
    printf("xbed: state idle\n");
    if
        :: true -> out ! Execute; goto WaitForExecuteAck;
        :: true -> out ! Shutdown; goto WaitForShutdownAck;
    fi;

WaitForExecuteAck:
    printf("xbed: waiting for execute-ack\n");
    /* XbedSentJob = true; */
    retryCounter = 0;
    do
    :: in ? ExecuteAck ->
        printf("xbed: got ack\n");
progress_execute:
        goto StBusy;
    :: timeout ->
        if
        :: (retryCounter < MAX_RETRIES) ->
            out ! Execute;
            retryCounter++;
        :: else ->
            goto StFailed;
        fi;
    od;

WaitForShutdownAck:
    printf("xbed: waiting for shutdown-ack\n");
    retryCounter = 0;
    do
    :: in ? ShutdownAck -> goto StShutdown;
    :: timeout ->
        if
        :: (retryCounter < MAX_RETRIES) ->
            out ! Shutdown;
            retryCounter++;
        :: else ->
            goto StFailed;
        fi;
    od;

WaitForTerminateAck:
    printf("xbed: waiting for terminate-ack\n");
    retryCounter = 0;
    do
    :: in ? TerminateAck -> goto StIdle;
    :: timeout ->
        if
        :: (retryCounter < MAX_RETRIES) ->
            out ! Terminate;
            retryCounter++;
        :: else ->
            goto StFailed;
        fi;
    od;

StBusy:
    printf("xbed: state busy\n");
    if
        :: in ? Finished -> out ! FinishedAck; goto StIdle;
        :: true -> out ! Terminate; goto WaitForTerminateAck;
        :: true -> out ! Shutdown; goto WaitForShutdownAck;
/*
        :: timeout ->
            if
                :: true -> out ! Terminate; goto WaitForTerminateAck;
                :: true -> out ! Shutdown; goto WaitForShutdownAck;
            fi;
*/
    fi;

StFailed:
    printf("xbed: failed\n");
StShutdown:
end:
    atomic { done = done + 1; }
    printf("xbed: done\n");
}

proctype lossy_daemon(chan c1, c2) {
    do
    :: c1 ? _; printf("message lost\n");
    :: c2 ? _; printf("message lost\n");
    :: (done == 2) -> goto end;
    od;
end:
    skip;
}

init {
    chan x2i = [CHAN_SIZE] of {mtype};
    chan i2x = [CHAN_SIZE] of {mtype};

    atomic {
        run Xbed(i2x, x2i);
        run Inst(x2i, i2x);
//        run lossy_daemon(i2x, x2i);
    }

    do 
        :: (done == 2) -> break;
    od;
}

