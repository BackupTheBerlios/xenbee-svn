mtype = {LifeSign, Execute, ExecuteAck, ExecuteNAck, Terminate, TerminateAck, Finished, FinishedAck, StatusReq, Status, Start, Shutdown, ShutdownAck};
chan toXbed = [0] of {mtype};
chan toInst = [0] of {mtype};
chan xend = [0] of {mtype};

byte done = 0;

/* define outcomes */
byte inst_failed = 0;

proctype Inst(chan in, out)
{
/*
  byte maxRetries = 3;
  byte retries = 0;
*/

  if
  :: in ? Start -> 
        /* simulate instance startup failure */
        if
        :: true -> out ! LifeSign; goto StIdle;
        :: true -> goto StFailed;
        fi;
  :: timeout -> goto StTerminated;
  fi;

StIdle:
/* accept new jobs, status requests and send life signals,
   it is also possible to get terminate messages that are
   handled as no ops */
  printf("inst: state idle\n");
  if
  :: in ? Execute ->
     printf("inst: got execute request\n");
     out ! ExecuteAck;
     goto StBusy;
/*
  :: in ? StatusReq ->
     printf("inst: got status request request\n");
     out ! Status;
     goto StIdle;
*/
  :: in ? Terminate ->
     printf("inst: got terminate request\n");
     out ! TerminateAck;
     goto StIdle;
  :: in ? Shutdown ->
     printf("inst: got shutdown request\n");
     out ! ShutdownAck;
     goto StTerminated;
  :: true -> out ! LifeSign; goto StIdle;
/* TODO: add this later */
/*  :: true -> goto StFailed; simulate VM failure */
  fi;

StBusy:
  printf("inst: state busy\n");
  if
  :: in ? Execute ->
     printf("inst: got execute request\n");
     out ! ExecuteNAck;
     goto StBusy;
/*
  :: in ? StatusReq ->
     printf("inst: got status request request\n");
     out ! Status;
     goto StBusy;
*/
  :: in ? Terminate ->
     printf("inst: got terminate request\n");
     out ! TerminateAck;
     goto StIdle;
  :: in ? Shutdown ->
     printf("inst: got shutdown request\n");
     out ! ShutdownAck;
     goto StTerminated;
  /* spontaneously send life signal or marking the job as finished */
  :: out ! LifeSign; goto StBusy;
  :: out ! Finished;
    printf("inst: execution finished\n");
    do 
    :: in ? FinishedAck -> goto StIdle
    od;
  fi;

StFailed:  
  inst_failed = 1;
StTerminated:
  atomic { done = done + 1; }
  printf("inst: done\n");
}

proctype Xbed(chan in, out)
{
/*
  byte maxRetries = 3;
  byte retries = 0;
*/

/* initial BES state model states */
StPendingReserved:
  if
  /* model user interaction */
  :: true -> goto StPendingConfirmed;
  :: true -> goto StTerminated;
  fi;

StPendingConfirmed:
  if
  :: true -> goto StInstanceStarting;
  :: true -> goto StTerminated;
  fi;

StInstanceStarting:
  out ! Start;
  if
  :: in ? LifeSign -> goto StIdle;
  :: timeout -> goto StFailed;
  fi;

StIdle:
  printf("xbed: state idle\n");
  if
  :: in ? Status -> goto StIdle;
  :: in ? ExecuteAck -> printf("xbed: job executing\n"); goto StBusy;
  :: in ? LifeSign -> goto StIdle;
/*
  :: out ! StatusReq; goto StIdle;
*/
  :: out ! Execute; goto StIdle;
  /* did not receive life signal or any other message */
  :: timeout -> goto StFailed;
  fi;

StBusy:
  printf("xbed: state busy\n");
  if
  :: in ? LifeSign -> goto StBusy;
  :: in ? Status   -> goto StBusy;
  :: in ? Finished -> out ! FinishedAck; goto StFinished;
/*
  :: out ! StatusReq; goto StBusy;
*/
  :: timeout -> goto StFailed;
  fi;

StFinished:
  printf("xbed: state finished\n");
  /* clean up */
  do
  :: in ? LifeSign -> skip;
/*
  :: in ? Status -> skip;
*/
  :: out ! Shutdown; break;
  od;
  do
  :: in ? LifeSign -> skip;
  :: in ? Status -> skip;
  :: in ? ShutdownAck -> goto StTerminated;
  :: timeout -> goto StTerminated;
  od;
StFailed:
StTerminated:
StDone:
  atomic { done = done + 1; }
  printf("xbed: done\n");
}

init {
  chan c[2] = [1] of {mtype};
  atomic { run Xbed(c[0], c[1]); run Inst(c[1], c[0]) };
  do 
  :: (done == 2) -> break;
  od;
}
