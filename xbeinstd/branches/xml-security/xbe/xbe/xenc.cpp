// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "xenc.hpp"

namespace xenc
{
  // EncryptedType
  // 

  const EncryptedType::EncryptionMethod_optional& EncryptedType::
  EncryptionMethod () const
  {
    return this->EncryptionMethod_;
  }

  EncryptedType::EncryptionMethod_optional& EncryptedType::
  EncryptionMethod ()
  {
    return this->EncryptionMethod_;
  }

  void EncryptedType::
  EncryptionMethod (const EncryptionMethod_type& x)
  {
    this->EncryptionMethod_.set (x);
  }

  void EncryptedType::
  EncryptionMethod (const EncryptionMethod_optional& x)
  {
    this->EncryptionMethod_ = x;
  }

  void EncryptedType::
  EncryptionMethod (::std::auto_ptr< EncryptionMethod_type > x)
  {
    this->EncryptionMethod_.set (x);
  }

  const EncryptedType::KeyInfo_optional& EncryptedType::
  KeyInfo () const
  {
    return this->KeyInfo_;
  }

  EncryptedType::KeyInfo_optional& EncryptedType::
  KeyInfo ()
  {
    return this->KeyInfo_;
  }

  void EncryptedType::
  KeyInfo (const KeyInfo_type& x)
  {
    this->KeyInfo_.set (x);
  }

  void EncryptedType::
  KeyInfo (const KeyInfo_optional& x)
  {
    this->KeyInfo_ = x;
  }

  void EncryptedType::
  KeyInfo (::std::auto_ptr< KeyInfo_type > x)
  {
    this->KeyInfo_.set (x);
  }

  const EncryptedType::CipherData_type& EncryptedType::
  CipherData () const
  {
    return this->CipherData_.get ();
  }

  EncryptedType::CipherData_type& EncryptedType::
  CipherData ()
  {
    return this->CipherData_.get ();
  }

  void EncryptedType::
  CipherData (const CipherData_type& x)
  {
    this->CipherData_.set (x);
  }

  void EncryptedType::
  CipherData (::std::auto_ptr< CipherData_type > x)
  {
    this->CipherData_.set (x);
  }

  const EncryptedType::EncryptionProperties_optional& EncryptedType::
  EncryptionProperties () const
  {
    return this->EncryptionProperties_;
  }

  EncryptedType::EncryptionProperties_optional& EncryptedType::
  EncryptionProperties ()
  {
    return this->EncryptionProperties_;
  }

  void EncryptedType::
  EncryptionProperties (const EncryptionProperties_type& x)
  {
    this->EncryptionProperties_.set (x);
  }

  void EncryptedType::
  EncryptionProperties (const EncryptionProperties_optional& x)
  {
    this->EncryptionProperties_ = x;
  }

  void EncryptedType::
  EncryptionProperties (::std::auto_ptr< EncryptionProperties_type > x)
  {
    this->EncryptionProperties_.set (x);
  }

  const EncryptedType::Id_optional& EncryptedType::
  Id () const
  {
    return this->Id_;
  }

  EncryptedType::Id_optional& EncryptedType::
  Id ()
  {
    return this->Id_;
  }

  void EncryptedType::
  Id (const Id_type& x)
  {
    this->Id_.set (x);
  }

  void EncryptedType::
  Id (const Id_optional& x)
  {
    this->Id_ = x;
  }

  void EncryptedType::
  Id (::std::auto_ptr< Id_type > x)
  {
    this->Id_.set (x);
  }

  const EncryptedType::Type_optional& EncryptedType::
  Type () const
  {
    return this->Type_;
  }

  EncryptedType::Type_optional& EncryptedType::
  Type ()
  {
    return this->Type_;
  }

  void EncryptedType::
  Type (const Type_type& x)
  {
    this->Type_.set (x);
  }

  void EncryptedType::
  Type (const Type_optional& x)
  {
    this->Type_ = x;
  }

  void EncryptedType::
  Type (::std::auto_ptr< Type_type > x)
  {
    this->Type_.set (x);
  }

  const EncryptedType::MimeType_optional& EncryptedType::
  MimeType () const
  {
    return this->MimeType_;
  }

  EncryptedType::MimeType_optional& EncryptedType::
  MimeType ()
  {
    return this->MimeType_;
  }

  void EncryptedType::
  MimeType (const MimeType_type& x)
  {
    this->MimeType_.set (x);
  }

  void EncryptedType::
  MimeType (const MimeType_optional& x)
  {
    this->MimeType_ = x;
  }

  void EncryptedType::
  MimeType (::std::auto_ptr< MimeType_type > x)
  {
    this->MimeType_.set (x);
  }

  const EncryptedType::Encoding_optional& EncryptedType::
  Encoding () const
  {
    return this->Encoding_;
  }

  EncryptedType::Encoding_optional& EncryptedType::
  Encoding ()
  {
    return this->Encoding_;
  }

  void EncryptedType::
  Encoding (const Encoding_type& x)
  {
    this->Encoding_.set (x);
  }

  void EncryptedType::
  Encoding (const Encoding_optional& x)
  {
    this->Encoding_ = x;
  }

  void EncryptedType::
  Encoding (::std::auto_ptr< Encoding_type > x)
  {
    this->Encoding_.set (x);
  }


  // EncryptionMethodType
  // 

  const EncryptionMethodType::KeySize_optional& EncryptionMethodType::
  KeySize () const
  {
    return this->KeySize_;
  }

  EncryptionMethodType::KeySize_optional& EncryptionMethodType::
  KeySize ()
  {
    return this->KeySize_;
  }

  void EncryptionMethodType::
  KeySize (const KeySize_type& x)
  {
    this->KeySize_.set (x);
  }

  void EncryptionMethodType::
  KeySize (const KeySize_optional& x)
  {
    this->KeySize_ = x;
  }

  void EncryptionMethodType::
  KeySize (::std::auto_ptr< KeySize_type > x)
  {
    this->KeySize_.set (x);
  }

  const EncryptionMethodType::OAEPparams_optional& EncryptionMethodType::
  OAEPparams () const
  {
    return this->OAEPparams_;
  }

  EncryptionMethodType::OAEPparams_optional& EncryptionMethodType::
  OAEPparams ()
  {
    return this->OAEPparams_;
  }

  void EncryptionMethodType::
  OAEPparams (const OAEPparams_type& x)
  {
    this->OAEPparams_.set (x);
  }

  void EncryptionMethodType::
  OAEPparams (const OAEPparams_optional& x)
  {
    this->OAEPparams_ = x;
  }

  void EncryptionMethodType::
  OAEPparams (::std::auto_ptr< OAEPparams_type > x)
  {
    this->OAEPparams_.set (x);
  }

  const EncryptionMethodType::any_sequence& EncryptionMethodType::
  any () const
  {
    return this->any_;
  }

  EncryptionMethodType::any_sequence& EncryptionMethodType::
  any ()
  {
    return this->any_;
  }

  void EncryptionMethodType::
  any (const any_sequence& s)
  {
    this->any_ = s;
  }

  const EncryptionMethodType::Algorithm_type& EncryptionMethodType::
  Algorithm () const
  {
    return this->Algorithm_.get ();
  }

  EncryptionMethodType::Algorithm_type& EncryptionMethodType::
  Algorithm ()
  {
    return this->Algorithm_.get ();
  }

  void EncryptionMethodType::
  Algorithm (const Algorithm_type& x)
  {
    this->Algorithm_.set (x);
  }

  void EncryptionMethodType::
  Algorithm (::std::auto_ptr< Algorithm_type > x)
  {
    this->Algorithm_.set (x);
  }

  const ::xercesc::DOMDocument& EncryptionMethodType::
  dom_document () const
  {
    return *dom_document_;
  }

  ::xercesc::DOMDocument& EncryptionMethodType::
  dom_document ()
  {
    return *dom_document_;
  }


  // KeySizeType
  // 


  // CipherDataType
  // 

  const CipherDataType::CipherValue_optional& CipherDataType::
  CipherValue () const
  {
    return this->CipherValue_;
  }

  CipherDataType::CipherValue_optional& CipherDataType::
  CipherValue ()
  {
    return this->CipherValue_;
  }

  void CipherDataType::
  CipherValue (const CipherValue_type& x)
  {
    this->CipherValue_.set (x);
  }

  void CipherDataType::
  CipherValue (const CipherValue_optional& x)
  {
    this->CipherValue_ = x;
  }

  void CipherDataType::
  CipherValue (::std::auto_ptr< CipherValue_type > x)
  {
    this->CipherValue_.set (x);
  }

  const CipherDataType::CipherReference_optional& CipherDataType::
  CipherReference () const
  {
    return this->CipherReference_;
  }

  CipherDataType::CipherReference_optional& CipherDataType::
  CipherReference ()
  {
    return this->CipherReference_;
  }

  void CipherDataType::
  CipherReference (const CipherReference_type& x)
  {
    this->CipherReference_.set (x);
  }

  void CipherDataType::
  CipherReference (const CipherReference_optional& x)
  {
    this->CipherReference_ = x;
  }

  void CipherDataType::
  CipherReference (::std::auto_ptr< CipherReference_type > x)
  {
    this->CipherReference_.set (x);
  }


  // CipherReferenceType
  // 

  const CipherReferenceType::Transforms_optional& CipherReferenceType::
  Transforms () const
  {
    return this->Transforms_;
  }

  CipherReferenceType::Transforms_optional& CipherReferenceType::
  Transforms ()
  {
    return this->Transforms_;
  }

  void CipherReferenceType::
  Transforms (const Transforms_type& x)
  {
    this->Transforms_.set (x);
  }

  void CipherReferenceType::
  Transforms (const Transforms_optional& x)
  {
    this->Transforms_ = x;
  }

  void CipherReferenceType::
  Transforms (::std::auto_ptr< Transforms_type > x)
  {
    this->Transforms_.set (x);
  }

  const CipherReferenceType::URI_type& CipherReferenceType::
  URI () const
  {
    return this->URI_.get ();
  }

  CipherReferenceType::URI_type& CipherReferenceType::
  URI ()
  {
    return this->URI_.get ();
  }

  void CipherReferenceType::
  URI (const URI_type& x)
  {
    this->URI_.set (x);
  }

  void CipherReferenceType::
  URI (::std::auto_ptr< URI_type > x)
  {
    this->URI_.set (x);
  }


  // TransformsType
  // 

  const TransformsType::Transform_sequence& TransformsType::
  Transform () const
  {
    return this->Transform_;
  }

  TransformsType::Transform_sequence& TransformsType::
  Transform ()
  {
    return this->Transform_;
  }

  void TransformsType::
  Transform (const Transform_sequence& s)
  {
    this->Transform_ = s;
  }


  // EncryptedDataType
  // 


  // EncryptedKeyType
  // 

  const EncryptedKeyType::ReferenceList_optional& EncryptedKeyType::
  ReferenceList () const
  {
    return this->ReferenceList_;
  }

  EncryptedKeyType::ReferenceList_optional& EncryptedKeyType::
  ReferenceList ()
  {
    return this->ReferenceList_;
  }

  void EncryptedKeyType::
  ReferenceList (const ReferenceList_type& x)
  {
    this->ReferenceList_.set (x);
  }

  void EncryptedKeyType::
  ReferenceList (const ReferenceList_optional& x)
  {
    this->ReferenceList_ = x;
  }

  void EncryptedKeyType::
  ReferenceList (::std::auto_ptr< ReferenceList_type > x)
  {
    this->ReferenceList_.set (x);
  }

  const EncryptedKeyType::CarriedKeyName_optional& EncryptedKeyType::
  CarriedKeyName () const
  {
    return this->CarriedKeyName_;
  }

  EncryptedKeyType::CarriedKeyName_optional& EncryptedKeyType::
  CarriedKeyName ()
  {
    return this->CarriedKeyName_;
  }

  void EncryptedKeyType::
  CarriedKeyName (const CarriedKeyName_type& x)
  {
    this->CarriedKeyName_.set (x);
  }

  void EncryptedKeyType::
  CarriedKeyName (const CarriedKeyName_optional& x)
  {
    this->CarriedKeyName_ = x;
  }

  void EncryptedKeyType::
  CarriedKeyName (::std::auto_ptr< CarriedKeyName_type > x)
  {
    this->CarriedKeyName_.set (x);
  }

  const EncryptedKeyType::Recipient_optional& EncryptedKeyType::
  Recipient () const
  {
    return this->Recipient_;
  }

  EncryptedKeyType::Recipient_optional& EncryptedKeyType::
  Recipient ()
  {
    return this->Recipient_;
  }

  void EncryptedKeyType::
  Recipient (const Recipient_type& x)
  {
    this->Recipient_.set (x);
  }

  void EncryptedKeyType::
  Recipient (const Recipient_optional& x)
  {
    this->Recipient_ = x;
  }

  void EncryptedKeyType::
  Recipient (::std::auto_ptr< Recipient_type > x)
  {
    this->Recipient_.set (x);
  }


  // AgreementMethodType
  // 

  const AgreementMethodType::KA_Nonce_optional& AgreementMethodType::
  KA_Nonce () const
  {
    return this->KA_Nonce_;
  }

  AgreementMethodType::KA_Nonce_optional& AgreementMethodType::
  KA_Nonce ()
  {
    return this->KA_Nonce_;
  }

  void AgreementMethodType::
  KA_Nonce (const KA_Nonce_type& x)
  {
    this->KA_Nonce_.set (x);
  }

  void AgreementMethodType::
  KA_Nonce (const KA_Nonce_optional& x)
  {
    this->KA_Nonce_ = x;
  }

  void AgreementMethodType::
  KA_Nonce (::std::auto_ptr< KA_Nonce_type > x)
  {
    this->KA_Nonce_.set (x);
  }

  const AgreementMethodType::any_sequence& AgreementMethodType::
  any () const
  {
    return this->any_;
  }

  AgreementMethodType::any_sequence& AgreementMethodType::
  any ()
  {
    return this->any_;
  }

  void AgreementMethodType::
  any (const any_sequence& s)
  {
    this->any_ = s;
  }

  const AgreementMethodType::OriginatorKeyInfo_optional& AgreementMethodType::
  OriginatorKeyInfo () const
  {
    return this->OriginatorKeyInfo_;
  }

  AgreementMethodType::OriginatorKeyInfo_optional& AgreementMethodType::
  OriginatorKeyInfo ()
  {
    return this->OriginatorKeyInfo_;
  }

  void AgreementMethodType::
  OriginatorKeyInfo (const OriginatorKeyInfo_type& x)
  {
    this->OriginatorKeyInfo_.set (x);
  }

  void AgreementMethodType::
  OriginatorKeyInfo (const OriginatorKeyInfo_optional& x)
  {
    this->OriginatorKeyInfo_ = x;
  }

  void AgreementMethodType::
  OriginatorKeyInfo (::std::auto_ptr< OriginatorKeyInfo_type > x)
  {
    this->OriginatorKeyInfo_.set (x);
  }

  const AgreementMethodType::RecipientKeyInfo_optional& AgreementMethodType::
  RecipientKeyInfo () const
  {
    return this->RecipientKeyInfo_;
  }

  AgreementMethodType::RecipientKeyInfo_optional& AgreementMethodType::
  RecipientKeyInfo ()
  {
    return this->RecipientKeyInfo_;
  }

  void AgreementMethodType::
  RecipientKeyInfo (const RecipientKeyInfo_type& x)
  {
    this->RecipientKeyInfo_.set (x);
  }

  void AgreementMethodType::
  RecipientKeyInfo (const RecipientKeyInfo_optional& x)
  {
    this->RecipientKeyInfo_ = x;
  }

  void AgreementMethodType::
  RecipientKeyInfo (::std::auto_ptr< RecipientKeyInfo_type > x)
  {
    this->RecipientKeyInfo_.set (x);
  }

  const AgreementMethodType::Algorithm_type& AgreementMethodType::
  Algorithm () const
  {
    return this->Algorithm_.get ();
  }

  AgreementMethodType::Algorithm_type& AgreementMethodType::
  Algorithm ()
  {
    return this->Algorithm_.get ();
  }

  void AgreementMethodType::
  Algorithm (const Algorithm_type& x)
  {
    this->Algorithm_.set (x);
  }

  void AgreementMethodType::
  Algorithm (::std::auto_ptr< Algorithm_type > x)
  {
    this->Algorithm_.set (x);
  }

  const ::xercesc::DOMDocument& AgreementMethodType::
  dom_document () const
  {
    return *dom_document_;
  }

  ::xercesc::DOMDocument& AgreementMethodType::
  dom_document ()
  {
    return *dom_document_;
  }


  // ReferenceType
  // 

  const ReferenceType::any_sequence& ReferenceType::
  any () const
  {
    return this->any_;
  }

  ReferenceType::any_sequence& ReferenceType::
  any ()
  {
    return this->any_;
  }

  void ReferenceType::
  any (const any_sequence& s)
  {
    this->any_ = s;
  }

  const ReferenceType::URI_type& ReferenceType::
  URI () const
  {
    return this->URI_.get ();
  }

  ReferenceType::URI_type& ReferenceType::
  URI ()
  {
    return this->URI_.get ();
  }

  void ReferenceType::
  URI (const URI_type& x)
  {
    this->URI_.set (x);
  }

  void ReferenceType::
  URI (::std::auto_ptr< URI_type > x)
  {
    this->URI_.set (x);
  }

  const ::xercesc::DOMDocument& ReferenceType::
  dom_document () const
  {
    return *dom_document_;
  }

  ::xercesc::DOMDocument& ReferenceType::
  dom_document ()
  {
    return *dom_document_;
  }


  // EncryptionPropertiesType
  // 

  const EncryptionPropertiesType::EncryptionProperty_sequence& EncryptionPropertiesType::
  EncryptionProperty () const
  {
    return this->EncryptionProperty_;
  }

  EncryptionPropertiesType::EncryptionProperty_sequence& EncryptionPropertiesType::
  EncryptionProperty ()
  {
    return this->EncryptionProperty_;
  }

  void EncryptionPropertiesType::
  EncryptionProperty (const EncryptionProperty_sequence& s)
  {
    this->EncryptionProperty_ = s;
  }

  const EncryptionPropertiesType::Id_optional& EncryptionPropertiesType::
  Id () const
  {
    return this->Id_;
  }

  EncryptionPropertiesType::Id_optional& EncryptionPropertiesType::
  Id ()
  {
    return this->Id_;
  }

  void EncryptionPropertiesType::
  Id (const Id_type& x)
  {
    this->Id_.set (x);
  }

  void EncryptionPropertiesType::
  Id (const Id_optional& x)
  {
    this->Id_ = x;
  }

  void EncryptionPropertiesType::
  Id (::std::auto_ptr< Id_type > x)
  {
    this->Id_.set (x);
  }


  // EncryptionPropertyType
  // 

  const EncryptionPropertyType::any_sequence& EncryptionPropertyType::
  any () const
  {
    return this->any_;
  }

  EncryptionPropertyType::any_sequence& EncryptionPropertyType::
  any ()
  {
    return this->any_;
  }

  void EncryptionPropertyType::
  any (const any_sequence& s)
  {
    this->any_ = s;
  }

  const EncryptionPropertyType::Target_optional& EncryptionPropertyType::
  Target () const
  {
    return this->Target_;
  }

  EncryptionPropertyType::Target_optional& EncryptionPropertyType::
  Target ()
  {
    return this->Target_;
  }

  void EncryptionPropertyType::
  Target (const Target_type& x)
  {
    this->Target_.set (x);
  }

  void EncryptionPropertyType::
  Target (const Target_optional& x)
  {
    this->Target_ = x;
  }

  void EncryptionPropertyType::
  Target (::std::auto_ptr< Target_type > x)
  {
    this->Target_.set (x);
  }

  const EncryptionPropertyType::Id_optional& EncryptionPropertyType::
  Id () const
  {
    return this->Id_;
  }

  EncryptionPropertyType::Id_optional& EncryptionPropertyType::
  Id ()
  {
    return this->Id_;
  }

  void EncryptionPropertyType::
  Id (const Id_type& x)
  {
    this->Id_.set (x);
  }

  void EncryptionPropertyType::
  Id (const Id_optional& x)
  {
    this->Id_ = x;
  }

  void EncryptionPropertyType::
  Id (::std::auto_ptr< Id_type > x)
  {
    this->Id_.set (x);
  }

  const EncryptionPropertyType::any_attribute_set& EncryptionPropertyType::
  any_attribute () const
  {
    return this->any_attribute_;
  }

  EncryptionPropertyType::any_attribute_set& EncryptionPropertyType::
  any_attribute ()
  {
    return this->any_attribute_;
  }

  void EncryptionPropertyType::
  any_attribute (const any_attribute_set& s)
  {
    this->any_attribute_ = s;
  }

  const ::xercesc::DOMDocument& EncryptionPropertyType::
  dom_document () const
  {
    return *dom_document_;
  }

  ::xercesc::DOMDocument& EncryptionPropertyType::
  dom_document ()
  {
    return *dom_document_;
  }


  // ReferenceList
  // 

  const ReferenceList::DataReference_sequence& ReferenceList::
  DataReference () const
  {
    return this->DataReference_;
  }

  ReferenceList::DataReference_sequence& ReferenceList::
  DataReference ()
  {
    return this->DataReference_;
  }

  void ReferenceList::
  DataReference (const DataReference_sequence& s)
  {
    this->DataReference_ = s;
  }

  const ReferenceList::KeyReference_sequence& ReferenceList::
  KeyReference () const
  {
    return this->KeyReference_;
  }

  ReferenceList::KeyReference_sequence& ReferenceList::
  KeyReference ()
  {
    return this->KeyReference_;
  }

  void ReferenceList::
  KeyReference (const KeyReference_sequence& s)
  {
    this->KeyReference_ = s;
  }
}

#include <xsd/cxx/xml/dom/wildcard-source.hxx>

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace xenc
{
  // EncryptedType
  //

  EncryptedType::
  EncryptedType (const CipherData_type& CipherData)
  : ::xml_schema::type (),
    EncryptionMethod_ (::xml_schema::flags (), this),
    KeyInfo_ (::xml_schema::flags (), this),
    CipherData_ (CipherData, ::xml_schema::flags (), this),
    EncryptionProperties_ (::xml_schema::flags (), this),
    Id_ (::xml_schema::flags (), this),
    Type_ (::xml_schema::flags (), this),
    MimeType_ (::xml_schema::flags (), this),
    Encoding_ (::xml_schema::flags (), this)
  {
  }

  EncryptedType::
  EncryptedType (const EncryptedType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    EncryptionMethod_ (x.EncryptionMethod_, f, this),
    KeyInfo_ (x.KeyInfo_, f, this),
    CipherData_ (x.CipherData_, f, this),
    EncryptionProperties_ (x.EncryptionProperties_, f, this),
    Id_ (x.Id_, f, this),
    Type_ (x.Type_, f, this),
    MimeType_ (x.MimeType_, f, this),
    Encoding_ (x.Encoding_, f, this)
  {
  }

  EncryptedType::
  EncryptedType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    EncryptionMethod_ (f, this),
    KeyInfo_ (f, this),
    CipherData_ (f, this),
    EncryptionProperties_ (f, this),
    Id_ (f, this),
    Type_ (f, this),
    MimeType_ (f, this),
    Encoding_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);
      this->parse (p, f);
    }
  }

  void EncryptedType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // EncryptionMethod
      //
      if (n.name () == "EncryptionMethod" && n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
      {
        ::std::auto_ptr< EncryptionMethod_type > r (
          EncryptionMethod_traits::create (i, f, this));

        if (!this->EncryptionMethod ())
        {
          this->EncryptionMethod (r);
          continue;
        }
      }

      // KeyInfo
      //
      if (n.name () == "KeyInfo" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::auto_ptr< KeyInfo_type > r (
          KeyInfo_traits::create (i, f, this));

        if (!this->KeyInfo ())
        {
          this->KeyInfo (r);
          continue;
        }
      }

      // CipherData
      //
      if (n.name () == "CipherData" && n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
      {
        ::std::auto_ptr< CipherData_type > r (
          CipherData_traits::create (i, f, this));

        if (!CipherData_.present ())
        {
          this->CipherData (r);
          continue;
        }
      }

      // EncryptionProperties
      //
      if (n.name () == "EncryptionProperties" && n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
      {
        ::std::auto_ptr< EncryptionProperties_type > r (
          EncryptionProperties_traits::create (i, f, this));

        if (!this->EncryptionProperties ())
        {
          this->EncryptionProperties (r);
          continue;
        }
      }

      break;
    }

    if (!CipherData_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CipherData",
        "http://www.w3.org/2001/04/xmlenc#");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Id_type > r (
          Id_traits::create (i, f, this));

        this->Id (r);
        continue;
      }

      if (n.name () == "Type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Type_type > r (
          Type_traits::create (i, f, this));

        this->Type (r);
        continue;
      }

      if (n.name () == "MimeType" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< MimeType_type > r (
          MimeType_traits::create (i, f, this));

        this->MimeType (r);
        continue;
      }

      if (n.name () == "Encoding" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Encoding_type > r (
          Encoding_traits::create (i, f, this));

        this->Encoding (r);
        continue;
      }
    }
  }

  EncryptedType* EncryptedType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new EncryptedType (*this, f, c);
  }

  EncryptedType::
  ~EncryptedType ()
  {
  }

  // EncryptionMethodType
  //

  EncryptionMethodType::
  EncryptionMethodType (const Algorithm_type& Algorithm)
  : ::xml_schema::type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    KeySize_ (::xml_schema::flags (), this),
    OAEPparams_ (::xml_schema::flags (), this),
    any_ (this->dom_document ()),
    Algorithm_ (Algorithm, ::xml_schema::flags (), this)
  {
  }

  EncryptionMethodType::
  EncryptionMethodType (const EncryptionMethodType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    KeySize_ (x.KeySize_, f, this),
    OAEPparams_ (x.OAEPparams_, f, this),
    any_ (x.any_, this->dom_document ()),
    Algorithm_ (x.Algorithm_, f, this)
  {
  }

  EncryptionMethodType::
  EncryptionMethodType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    KeySize_ (f, this),
    OAEPparams_ (f, this),
    any_ (this->dom_document ()),
    Algorithm_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);
      this->parse (p, f);
    }
  }

  void EncryptionMethodType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // KeySize
      //
      if (n.name () == "KeySize" && n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
      {
        ::std::auto_ptr< KeySize_type > r (
          KeySize_traits::create (i, f, this));

        if (!this->KeySize ())
        {
          this->KeySize (r);
          continue;
        }
      }

      // OAEPparams
      //
      if (n.name () == "OAEPparams" && n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
      {
        ::std::auto_ptr< OAEPparams_type > r (
          OAEPparams_traits::create (i, f, this));

        if (!this->OAEPparams ())
        {
          this->OAEPparams (r);
          continue;
        }
      }

      // any
      //
      if ((!n.namespace_ ().empty () && n.namespace_ () != "http://www.w3.org/2001/04/xmlenc#"))
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->dom_document ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any ().push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Algorithm" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Algorithm_type > r (
          Algorithm_traits::create (i, f, this));

        this->Algorithm (r);
        continue;
      }
    }

    if (!Algorithm_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Algorithm",
        "");
    }
  }

  EncryptionMethodType* EncryptionMethodType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new EncryptionMethodType (*this, f, c);
  }

  EncryptionMethodType::
  ~EncryptionMethodType ()
  {
  }

  // KeySizeType
  //

  KeySizeType::
  KeySizeType (const ::xml_schema::integer& integer)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (integer)
  {
  }

  KeySizeType::
  KeySizeType (const KeySizeType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  KeySizeType::
  KeySizeType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  KeySizeType::
  KeySizeType (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  KeySizeType::
  KeySizeType (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  KeySizeType* KeySizeType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new KeySizeType (*this, f, c);
  }

  KeySizeType::
  ~KeySizeType ()
  {
  }

  // CipherDataType
  //

  CipherDataType::
  CipherDataType ()
  : ::xml_schema::type (),
    CipherValue_ (::xml_schema::flags (), this),
    CipherReference_ (::xml_schema::flags (), this)
  {
  }

  CipherDataType::
  CipherDataType (const CipherDataType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    CipherValue_ (x.CipherValue_, f, this),
    CipherReference_ (x.CipherReference_, f, this)
  {
  }

  CipherDataType::
  CipherDataType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    CipherValue_ (f, this),
    CipherReference_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);
      this->parse (p, f);
    }
  }

  void CipherDataType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CipherValue
      //
      if (n.name () == "CipherValue" && n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
      {
        ::std::auto_ptr< CipherValue_type > r (
          CipherValue_traits::create (i, f, this));

        if (!this->CipherValue ())
        {
          this->CipherValue (r);
          continue;
        }
      }

      // CipherReference
      //
      if (n.name () == "CipherReference" && n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
      {
        ::std::auto_ptr< CipherReference_type > r (
          CipherReference_traits::create (i, f, this));

        if (!this->CipherReference ())
        {
          this->CipherReference (r);
          continue;
        }
      }

      break;
    }
  }

  CipherDataType* CipherDataType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new CipherDataType (*this, f, c);
  }

  CipherDataType::
  ~CipherDataType ()
  {
  }

  // CipherReferenceType
  //

  CipherReferenceType::
  CipherReferenceType (const URI_type& URI)
  : ::xml_schema::type (),
    Transforms_ (::xml_schema::flags (), this),
    URI_ (URI, ::xml_schema::flags (), this)
  {
  }

  CipherReferenceType::
  CipherReferenceType (const CipherReferenceType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Transforms_ (x.Transforms_, f, this),
    URI_ (x.URI_, f, this)
  {
  }

  CipherReferenceType::
  CipherReferenceType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Transforms_ (f, this),
    URI_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);
      this->parse (p, f);
    }
  }

  void CipherReferenceType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Transforms
      //
      if (n.name () == "Transforms" && n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
      {
        ::std::auto_ptr< Transforms_type > r (
          Transforms_traits::create (i, f, this));

        if (!this->Transforms ())
        {
          this->Transforms (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "URI" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< URI_type > r (
          URI_traits::create (i, f, this));

        this->URI (r);
        continue;
      }
    }

    if (!URI_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "URI",
        "");
    }
  }

  CipherReferenceType* CipherReferenceType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new CipherReferenceType (*this, f, c);
  }

  CipherReferenceType::
  ~CipherReferenceType ()
  {
  }

  // TransformsType
  //

  TransformsType::
  TransformsType ()
  : ::xml_schema::type (),
    Transform_ (::xml_schema::flags (), this)
  {
  }

  TransformsType::
  TransformsType (const TransformsType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Transform_ (x.Transform_, f, this)
  {
  }

  TransformsType::
  TransformsType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Transform_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);
      this->parse (p, f);
    }
  }

  void TransformsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Transform
      //
      if (n.name () == "Transform" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::auto_ptr< Transform_type > r (
          Transform_traits::create (i, f, this));

        this->Transform ().push_back (r);
        continue;
      }

      break;
    }
  }

  TransformsType* TransformsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new TransformsType (*this, f, c);
  }

  TransformsType::
  ~TransformsType ()
  {
  }

  // EncryptedDataType
  //

  EncryptedDataType::
  EncryptedDataType (const CipherData_type& CipherData)
  : ::xenc::EncryptedType (CipherData)
  {
  }

  EncryptedDataType::
  EncryptedDataType (const EncryptedDataType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xenc::EncryptedType (x, f, c)
  {
  }

  EncryptedDataType::
  EncryptedDataType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xenc::EncryptedType (e, f, c)
  {
  }

  EncryptedDataType* EncryptedDataType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new EncryptedDataType (*this, f, c);
  }

  EncryptedDataType::
  ~EncryptedDataType ()
  {
  }

  // EncryptedKeyType
  //

  EncryptedKeyType::
  EncryptedKeyType (const CipherData_type& CipherData)
  : ::xenc::EncryptedType (CipherData),
    ReferenceList_ (::xml_schema::flags (), this),
    CarriedKeyName_ (::xml_schema::flags (), this),
    Recipient_ (::xml_schema::flags (), this)
  {
  }

  EncryptedKeyType::
  EncryptedKeyType (const EncryptedKeyType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xenc::EncryptedType (x, f, c),
    ReferenceList_ (x.ReferenceList_, f, this),
    CarriedKeyName_ (x.CarriedKeyName_, f, this),
    Recipient_ (x.Recipient_, f, this)
  {
  }

  EncryptedKeyType::
  EncryptedKeyType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xenc::EncryptedType (e, f | ::xml_schema::flags::base, c),
    ReferenceList_ (f, this),
    CarriedKeyName_ (f, this),
    Recipient_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);
      this->parse (p, f);
    }
  }

  void EncryptedKeyType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::xenc::EncryptedType::parse (p, f);

    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ReferenceList
      //
      if (n.name () == "ReferenceList" && n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
      {
        ::std::auto_ptr< ReferenceList_type > r (
          ReferenceList_traits::create (i, f, this));

        if (!this->ReferenceList ())
        {
          this->ReferenceList (r);
          continue;
        }
      }

      // CarriedKeyName
      //
      if (n.name () == "CarriedKeyName" && n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
      {
        ::std::auto_ptr< CarriedKeyName_type > r (
          CarriedKeyName_traits::create (i, f, this));

        if (!this->CarriedKeyName ())
        {
          this->CarriedKeyName (r);
          continue;
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Recipient" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Recipient_type > r (
          Recipient_traits::create (i, f, this));

        this->Recipient (r);
        continue;
      }
    }
  }

  EncryptedKeyType* EncryptedKeyType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new EncryptedKeyType (*this, f, c);
  }

  EncryptedKeyType::
  ~EncryptedKeyType ()
  {
  }

  // AgreementMethodType
  //

  AgreementMethodType::
  AgreementMethodType (const Algorithm_type& Algorithm)
  : ::xml_schema::type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    KA_Nonce_ (::xml_schema::flags (), this),
    any_ (this->dom_document ()),
    OriginatorKeyInfo_ (::xml_schema::flags (), this),
    RecipientKeyInfo_ (::xml_schema::flags (), this),
    Algorithm_ (Algorithm, ::xml_schema::flags (), this)
  {
  }

  AgreementMethodType::
  AgreementMethodType (const AgreementMethodType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    KA_Nonce_ (x.KA_Nonce_, f, this),
    any_ (x.any_, this->dom_document ()),
    OriginatorKeyInfo_ (x.OriginatorKeyInfo_, f, this),
    RecipientKeyInfo_ (x.RecipientKeyInfo_, f, this),
    Algorithm_ (x.Algorithm_, f, this)
  {
  }

  AgreementMethodType::
  AgreementMethodType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    KA_Nonce_ (f, this),
    any_ (this->dom_document ()),
    OriginatorKeyInfo_ (f, this),
    RecipientKeyInfo_ (f, this),
    Algorithm_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);
      this->parse (p, f);
    }
  }

  void AgreementMethodType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // KA-Nonce
      //
      if (n.name () == "KA-Nonce" && n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
      {
        ::std::auto_ptr< KA_Nonce_type > r (
          KA_Nonce_traits::create (i, f, this));

        if (!this->KA_Nonce ())
        {
          this->KA_Nonce (r);
          continue;
        }
      }

      // any
      //
      if ((!n.namespace_ ().empty () && n.namespace_ () != "http://www.w3.org/2001/04/xmlenc#"))
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->dom_document ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any ().push_back (r);
        continue;
      }

      // OriginatorKeyInfo
      //
      if (n.name () == "OriginatorKeyInfo" && n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
      {
        ::std::auto_ptr< OriginatorKeyInfo_type > r (
          OriginatorKeyInfo_traits::create (i, f, this));

        if (!this->OriginatorKeyInfo ())
        {
          this->OriginatorKeyInfo (r);
          continue;
        }
      }

      // RecipientKeyInfo
      //
      if (n.name () == "RecipientKeyInfo" && n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
      {
        ::std::auto_ptr< RecipientKeyInfo_type > r (
          RecipientKeyInfo_traits::create (i, f, this));

        if (!this->RecipientKeyInfo ())
        {
          this->RecipientKeyInfo (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Algorithm" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Algorithm_type > r (
          Algorithm_traits::create (i, f, this));

        this->Algorithm (r);
        continue;
      }
    }

    if (!Algorithm_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Algorithm",
        "");
    }
  }

  AgreementMethodType* AgreementMethodType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new AgreementMethodType (*this, f, c);
  }

  AgreementMethodType::
  ~AgreementMethodType ()
  {
  }

  // ReferenceType
  //

  ReferenceType::
  ReferenceType (const URI_type& URI)
  : ::xml_schema::type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (this->dom_document ()),
    URI_ (URI, ::xml_schema::flags (), this)
  {
  }

  ReferenceType::
  ReferenceType (const ReferenceType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (x.any_, this->dom_document ()),
    URI_ (x.URI_, f, this)
  {
  }

  ReferenceType::
  ReferenceType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (this->dom_document ()),
    URI_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);
      this->parse (p, f);
    }
  }

  void ReferenceType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // any
      //
      if ((!n.namespace_ ().empty () && n.namespace_ () != "http://www.w3.org/2001/04/xmlenc#"))
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->dom_document ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any ().push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "URI" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< URI_type > r (
          URI_traits::create (i, f, this));

        this->URI (r);
        continue;
      }
    }

    if (!URI_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "URI",
        "");
    }
  }

  ReferenceType* ReferenceType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new ReferenceType (*this, f, c);
  }

  ReferenceType::
  ~ReferenceType ()
  {
  }

  // EncryptionPropertiesType
  //

  EncryptionPropertiesType::
  EncryptionPropertiesType ()
  : ::xml_schema::type (),
    EncryptionProperty_ (::xml_schema::flags (), this),
    Id_ (::xml_schema::flags (), this)
  {
  }

  EncryptionPropertiesType::
  EncryptionPropertiesType (const EncryptionPropertiesType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    EncryptionProperty_ (x.EncryptionProperty_, f, this),
    Id_ (x.Id_, f, this)
  {
  }

  EncryptionPropertiesType::
  EncryptionPropertiesType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    EncryptionProperty_ (f, this),
    Id_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);
      this->parse (p, f);
    }
  }

  void EncryptionPropertiesType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // EncryptionProperty
      //
      if (n.name () == "EncryptionProperty" && n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
      {
        ::std::auto_ptr< EncryptionProperty_type > r (
          EncryptionProperty_traits::create (i, f, this));

        this->EncryptionProperty ().push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Id_type > r (
          Id_traits::create (i, f, this));

        this->Id (r);
        continue;
      }
    }
  }

  EncryptionPropertiesType* EncryptionPropertiesType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new EncryptionPropertiesType (*this, f, c);
  }

  EncryptionPropertiesType::
  ~EncryptionPropertiesType ()
  {
  }

  // EncryptionPropertyType
  //

  EncryptionPropertyType::
  EncryptionPropertyType ()
  : ::xml_schema::type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (this->dom_document ()),
    Target_ (::xml_schema::flags (), this),
    Id_ (::xml_schema::flags (), this),
    any_attribute_ (this->dom_document ())
  {
  }

  EncryptionPropertyType::
  EncryptionPropertyType (const EncryptionPropertyType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (x.any_, this->dom_document ()),
    Target_ (x.Target_, f, this),
    Id_ (x.Id_, f, this),
    any_attribute_ (x.any_attribute_, this->dom_document ())
  {
  }

  EncryptionPropertyType::
  EncryptionPropertyType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (this->dom_document ()),
    Target_ (f, this),
    Id_ (f, this),
    any_attribute_ (this->dom_document ())
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);
      this->parse (p, f);
    }
  }

  void EncryptionPropertyType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // any
      //
      if ((!n.namespace_ ().empty () && n.namespace_ () != "http://www.w3.org/2001/04/xmlenc#"))
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->dom_document ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any ().push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Target" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Target_type > r (
          Target_traits::create (i, f, this));

        this->Target (r);
        continue;
      }

      if (n.name () == "Id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Id_type > r (
          Id_traits::create (i, f, this));

        this->Id (r);
        continue;
      }

      // any_attribute
      //
      if (n.namespace_ () == "http://www.w3.org/XML/1998/namespace")
      {
        ::xercesc::DOMAttr* r (
          static_cast< ::xercesc::DOMAttr* > (
            this->dom_document ().importNode (
              const_cast< ::xercesc::DOMAttr* > (&i), true)));
        this->any_attribute ().insert (r);
        continue;
      }
    }
  }

  EncryptionPropertyType* EncryptionPropertyType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new EncryptionPropertyType (*this, f, c);
  }

  EncryptionPropertyType::
  ~EncryptionPropertyType ()
  {
  }

  // ReferenceList
  //

  ReferenceList::
  ReferenceList ()
  : ::xml_schema::type (),
    DataReference_ (::xml_schema::flags (), this),
    KeyReference_ (::xml_schema::flags (), this)
  {
  }

  ReferenceList::
  ReferenceList (const ReferenceList& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DataReference_ (x.DataReference_, f, this),
    KeyReference_ (x.KeyReference_, f, this)
  {
  }

  ReferenceList::
  ReferenceList (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DataReference_ (f, this),
    KeyReference_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e);
      this->parse (p, f);
    }
  }

  void ReferenceList::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DataReference
      //
      if (n.name () == "DataReference" && n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
      {
        ::std::auto_ptr< DataReference_type > r (
          DataReference_traits::create (i, f, this));

        this->DataReference ().push_back (r);
        continue;
      }

      // KeyReference
      //
      if (n.name () == "KeyReference" && n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
      {
        ::std::auto_ptr< KeyReference_type > r (
          KeyReference_traits::create (i, f, this));

        this->KeyReference ().push_back (r);
        continue;
      }

      break;
    }
  }

  ReferenceList* ReferenceList::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new ReferenceList (*this, f, c);
  }

  ReferenceList::
  ~ReferenceList ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xenc
{
  ::std::auto_ptr< ::xenc::CipherDataType >
  CipherData (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::xenc::CipherDataType > r (
      ::xenc::CipherData (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::CipherDataType >
  CipherData (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::CipherDataType > r (
      ::xenc::CipherData (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::CipherDataType >
  CipherData (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::CipherDataType > r (
      ::xenc::CipherData (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::CipherDataType >
  CipherData (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::xenc::CipherData (isrc, f, p);
  }

  ::std::auto_ptr< ::xenc::CipherDataType >
  CipherData (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::xenc::CipherData (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::CipherDataType >
  CipherData (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::xenc::CipherData (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::CipherDataType >
  CipherData (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::xenc::CipherData (isrc, f, p);
  }

  ::std::auto_ptr< ::xenc::CipherDataType >
  CipherData (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::xenc::CipherData (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::CipherDataType >
  CipherData (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::xenc::CipherData (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::CipherDataType >
  CipherData (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::xenc::CipherDataType > r (
      ::xenc::CipherData (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::CipherDataType >
  CipherData (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::CipherDataType > r (
      ::xenc::CipherData (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::CipherDataType >
  CipherData (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::CipherDataType > r (
      ::xenc::CipherData (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::CipherDataType >
  CipherData (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::xenc::CipherDataType > r (
        ::xenc::CipherData (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "CipherData" &&
        n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
    {
      ::std::auto_ptr< ::xenc::CipherDataType > r (
        ::xsd::cxx::tree::traits< ::xenc::CipherDataType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "CipherData",
      "http://www.w3.org/2001/04/xmlenc#");
  }

  ::std::auto_ptr< ::xenc::CipherDataType >
  CipherData (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "CipherData" &&
        n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
    {
      ::std::auto_ptr< ::xenc::CipherDataType > r (
        ::xsd::cxx::tree::traits< ::xenc::CipherDataType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "CipherData",
      "http://www.w3.org/2001/04/xmlenc#");
  }

  ::std::auto_ptr< ::xenc::CipherReferenceType >
  CipherReference (const ::std::string& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::xenc::CipherReferenceType > r (
      ::xenc::CipherReference (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::CipherReferenceType >
  CipherReference (const ::std::string& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::CipherReferenceType > r (
      ::xenc::CipherReference (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::CipherReferenceType >
  CipherReference (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::CipherReferenceType > r (
      ::xenc::CipherReference (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::CipherReferenceType >
  CipherReference (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::xenc::CipherReference (isrc, f, p);
  }

  ::std::auto_ptr< ::xenc::CipherReferenceType >
  CipherReference (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::xenc::CipherReference (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::CipherReferenceType >
  CipherReference (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::xenc::CipherReference (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::CipherReferenceType >
  CipherReference (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::xenc::CipherReference (isrc, f, p);
  }

  ::std::auto_ptr< ::xenc::CipherReferenceType >
  CipherReference (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::xenc::CipherReference (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::CipherReferenceType >
  CipherReference (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::xenc::CipherReference (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::CipherReferenceType >
  CipherReference (::xercesc::InputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::xenc::CipherReferenceType > r (
      ::xenc::CipherReference (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::CipherReferenceType >
  CipherReference (::xercesc::InputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::CipherReferenceType > r (
      ::xenc::CipherReference (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::CipherReferenceType >
  CipherReference (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::CipherReferenceType > r (
      ::xenc::CipherReference (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::CipherReferenceType >
  CipherReference (const ::xercesc::DOMDocument& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::xenc::CipherReferenceType > r (
        ::xenc::CipherReference (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "CipherReference" &&
        n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
    {
      ::std::auto_ptr< ::xenc::CipherReferenceType > r (
        ::xsd::cxx::tree::traits< ::xenc::CipherReferenceType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "CipherReference",
      "http://www.w3.org/2001/04/xmlenc#");
  }

  ::std::auto_ptr< ::xenc::CipherReferenceType >
  CipherReference (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "CipherReference" &&
        n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
    {
      ::std::auto_ptr< ::xenc::CipherReferenceType > r (
        ::xsd::cxx::tree::traits< ::xenc::CipherReferenceType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "CipherReference",
      "http://www.w3.org/2001/04/xmlenc#");
  }

  ::std::auto_ptr< ::xenc::EncryptedDataType >
  EncryptedData (const ::std::string& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::xenc::EncryptedDataType > r (
      ::xenc::EncryptedData (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::EncryptedDataType >
  EncryptedData (const ::std::string& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::EncryptedDataType > r (
      ::xenc::EncryptedData (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::EncryptedDataType >
  EncryptedData (const ::std::string& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::EncryptedDataType > r (
      ::xenc::EncryptedData (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::EncryptedDataType >
  EncryptedData (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::xenc::EncryptedData (isrc, f, p);
  }

  ::std::auto_ptr< ::xenc::EncryptedDataType >
  EncryptedData (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::xenc::EncryptedData (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::EncryptedDataType >
  EncryptedData (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::xenc::EncryptedData (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::EncryptedDataType >
  EncryptedData (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::xenc::EncryptedData (isrc, f, p);
  }

  ::std::auto_ptr< ::xenc::EncryptedDataType >
  EncryptedData (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::xenc::EncryptedData (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::EncryptedDataType >
  EncryptedData (::std::istream& is,
                 const ::std::string& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::xenc::EncryptedData (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::EncryptedDataType >
  EncryptedData (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::xenc::EncryptedDataType > r (
      ::xenc::EncryptedData (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::EncryptedDataType >
  EncryptedData (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::EncryptedDataType > r (
      ::xenc::EncryptedData (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::EncryptedDataType >
  EncryptedData (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::EncryptedDataType > r (
      ::xenc::EncryptedData (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::EncryptedDataType >
  EncryptedData (const ::xercesc::DOMDocument& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::xenc::EncryptedDataType > r (
        ::xenc::EncryptedData (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "EncryptedData" &&
        n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
    {
      ::std::auto_ptr< ::xenc::EncryptedDataType > r (
        ::xsd::cxx::tree::traits< ::xenc::EncryptedDataType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EncryptedData",
      "http://www.w3.org/2001/04/xmlenc#");
  }

  ::std::auto_ptr< ::xenc::EncryptedDataType >
  EncryptedData (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "EncryptedData" &&
        n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
    {
      ::std::auto_ptr< ::xenc::EncryptedDataType > r (
        ::xsd::cxx::tree::traits< ::xenc::EncryptedDataType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EncryptedData",
      "http://www.w3.org/2001/04/xmlenc#");
  }

  ::std::auto_ptr< ::xenc::EncryptedKeyType >
  EncryptedKey (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::xenc::EncryptedKeyType > r (
      ::xenc::EncryptedKey (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::EncryptedKeyType >
  EncryptedKey (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::EncryptedKeyType > r (
      ::xenc::EncryptedKey (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::EncryptedKeyType >
  EncryptedKey (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::EncryptedKeyType > r (
      ::xenc::EncryptedKey (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::EncryptedKeyType >
  EncryptedKey (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::xenc::EncryptedKey (isrc, f, p);
  }

  ::std::auto_ptr< ::xenc::EncryptedKeyType >
  EncryptedKey (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::xenc::EncryptedKey (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::EncryptedKeyType >
  EncryptedKey (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::xenc::EncryptedKey (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::EncryptedKeyType >
  EncryptedKey (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::xenc::EncryptedKey (isrc, f, p);
  }

  ::std::auto_ptr< ::xenc::EncryptedKeyType >
  EncryptedKey (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::xenc::EncryptedKey (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::EncryptedKeyType >
  EncryptedKey (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::xenc::EncryptedKey (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::EncryptedKeyType >
  EncryptedKey (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::xenc::EncryptedKeyType > r (
      ::xenc::EncryptedKey (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::EncryptedKeyType >
  EncryptedKey (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::EncryptedKeyType > r (
      ::xenc::EncryptedKey (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::EncryptedKeyType >
  EncryptedKey (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::EncryptedKeyType > r (
      ::xenc::EncryptedKey (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::EncryptedKeyType >
  EncryptedKey (const ::xercesc::DOMDocument& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::xenc::EncryptedKeyType > r (
        ::xenc::EncryptedKey (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "EncryptedKey" &&
        n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
    {
      ::std::auto_ptr< ::xenc::EncryptedKeyType > r (
        ::xsd::cxx::tree::traits< ::xenc::EncryptedKeyType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EncryptedKey",
      "http://www.w3.org/2001/04/xmlenc#");
  }

  ::std::auto_ptr< ::xenc::EncryptedKeyType >
  EncryptedKey (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "EncryptedKey" &&
        n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
    {
      ::std::auto_ptr< ::xenc::EncryptedKeyType > r (
        ::xsd::cxx::tree::traits< ::xenc::EncryptedKeyType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EncryptedKey",
      "http://www.w3.org/2001/04/xmlenc#");
  }

  ::std::auto_ptr< ::xenc::AgreementMethodType >
  AgreementMethod (const ::std::string& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::xenc::AgreementMethodType > r (
      ::xenc::AgreementMethod (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::AgreementMethodType >
  AgreementMethod (const ::std::string& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::AgreementMethodType > r (
      ::xenc::AgreementMethod (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::AgreementMethodType >
  AgreementMethod (const ::std::string& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::AgreementMethodType > r (
      ::xenc::AgreementMethod (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::AgreementMethodType >
  AgreementMethod (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::xenc::AgreementMethod (isrc, f, p);
  }

  ::std::auto_ptr< ::xenc::AgreementMethodType >
  AgreementMethod (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::xenc::AgreementMethod (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::AgreementMethodType >
  AgreementMethod (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::xenc::AgreementMethod (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::AgreementMethodType >
  AgreementMethod (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::xenc::AgreementMethod (isrc, f, p);
  }

  ::std::auto_ptr< ::xenc::AgreementMethodType >
  AgreementMethod (::std::istream& is,
                   const ::std::string& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::xenc::AgreementMethod (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::AgreementMethodType >
  AgreementMethod (::std::istream& is,
                   const ::std::string& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::xenc::AgreementMethod (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::AgreementMethodType >
  AgreementMethod (::xercesc::InputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::xenc::AgreementMethodType > r (
      ::xenc::AgreementMethod (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::AgreementMethodType >
  AgreementMethod (::xercesc::InputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::AgreementMethodType > r (
      ::xenc::AgreementMethod (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::AgreementMethodType >
  AgreementMethod (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::AgreementMethodType > r (
      ::xenc::AgreementMethod (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::AgreementMethodType >
  AgreementMethod (const ::xercesc::DOMDocument& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::xenc::AgreementMethodType > r (
        ::xenc::AgreementMethod (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "AgreementMethod" &&
        n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
    {
      ::std::auto_ptr< ::xenc::AgreementMethodType > r (
        ::xsd::cxx::tree::traits< ::xenc::AgreementMethodType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "AgreementMethod",
      "http://www.w3.org/2001/04/xmlenc#");
  }

  ::std::auto_ptr< ::xenc::AgreementMethodType >
  AgreementMethod (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "AgreementMethod" &&
        n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
    {
      ::std::auto_ptr< ::xenc::AgreementMethodType > r (
        ::xsd::cxx::tree::traits< ::xenc::AgreementMethodType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "AgreementMethod",
      "http://www.w3.org/2001/04/xmlenc#");
  }

  ::std::auto_ptr< ::xenc::ReferenceList >
  ReferenceList_ (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::xenc::ReferenceList > r (
      ::xenc::ReferenceList_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::ReferenceList >
  ReferenceList_ (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::ReferenceList > r (
      ::xenc::ReferenceList_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::ReferenceList >
  ReferenceList_ (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::ReferenceList > r (
      ::xenc::ReferenceList_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::ReferenceList >
  ReferenceList_ (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::xenc::ReferenceList_ (isrc, f, p);
  }

  ::std::auto_ptr< ::xenc::ReferenceList >
  ReferenceList_ (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::xenc::ReferenceList_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::ReferenceList >
  ReferenceList_ (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::xenc::ReferenceList_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::ReferenceList >
  ReferenceList_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::xenc::ReferenceList_ (isrc, f, p);
  }

  ::std::auto_ptr< ::xenc::ReferenceList >
  ReferenceList_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::xenc::ReferenceList_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::ReferenceList >
  ReferenceList_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::xenc::ReferenceList_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::ReferenceList >
  ReferenceList_ (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::xenc::ReferenceList > r (
      ::xenc::ReferenceList_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::ReferenceList >
  ReferenceList_ (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::ReferenceList > r (
      ::xenc::ReferenceList_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::ReferenceList >
  ReferenceList_ (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::ReferenceList > r (
      ::xenc::ReferenceList_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::ReferenceList >
  ReferenceList_ (const ::xercesc::DOMDocument& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::xenc::ReferenceList > r (
        ::xenc::ReferenceList_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ReferenceList" &&
        n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
    {
      ::std::auto_ptr< ::xenc::ReferenceList > r (
        ::xsd::cxx::tree::traits< ::xenc::ReferenceList, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ReferenceList",
      "http://www.w3.org/2001/04/xmlenc#");
  }

  ::std::auto_ptr< ::xenc::ReferenceList >
  ReferenceList_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ReferenceList" &&
        n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
    {
      ::std::auto_ptr< ::xenc::ReferenceList > r (
        ::xsd::cxx::tree::traits< ::xenc::ReferenceList, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ReferenceList",
      "http://www.w3.org/2001/04/xmlenc#");
  }

  ::std::auto_ptr< ::xenc::EncryptionPropertiesType >
  EncryptionProperties (const ::std::string& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::xenc::EncryptionPropertiesType > r (
      ::xenc::EncryptionProperties (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::EncryptionPropertiesType >
  EncryptionProperties (const ::std::string& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::EncryptionPropertiesType > r (
      ::xenc::EncryptionProperties (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::EncryptionPropertiesType >
  EncryptionProperties (const ::std::string& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::EncryptionPropertiesType > r (
      ::xenc::EncryptionProperties (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::EncryptionPropertiesType >
  EncryptionProperties (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::xenc::EncryptionProperties (isrc, f, p);
  }

  ::std::auto_ptr< ::xenc::EncryptionPropertiesType >
  EncryptionProperties (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::xenc::EncryptionProperties (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::EncryptionPropertiesType >
  EncryptionProperties (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::xenc::EncryptionProperties (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::EncryptionPropertiesType >
  EncryptionProperties (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::xenc::EncryptionProperties (isrc, f, p);
  }

  ::std::auto_ptr< ::xenc::EncryptionPropertiesType >
  EncryptionProperties (::std::istream& is,
                        const ::std::string& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::xenc::EncryptionProperties (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::EncryptionPropertiesType >
  EncryptionProperties (::std::istream& is,
                        const ::std::string& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::xenc::EncryptionProperties (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::EncryptionPropertiesType >
  EncryptionProperties (::xercesc::InputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::xenc::EncryptionPropertiesType > r (
      ::xenc::EncryptionProperties (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::EncryptionPropertiesType >
  EncryptionProperties (::xercesc::InputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::EncryptionPropertiesType > r (
      ::xenc::EncryptionProperties (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::EncryptionPropertiesType >
  EncryptionProperties (::xercesc::InputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::EncryptionPropertiesType > r (
      ::xenc::EncryptionProperties (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::EncryptionPropertiesType >
  EncryptionProperties (const ::xercesc::DOMDocument& d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::xenc::EncryptionPropertiesType > r (
        ::xenc::EncryptionProperties (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "EncryptionProperties" &&
        n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
    {
      ::std::auto_ptr< ::xenc::EncryptionPropertiesType > r (
        ::xsd::cxx::tree::traits< ::xenc::EncryptionPropertiesType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EncryptionProperties",
      "http://www.w3.org/2001/04/xmlenc#");
  }

  ::std::auto_ptr< ::xenc::EncryptionPropertiesType >
  EncryptionProperties (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "EncryptionProperties" &&
        n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
    {
      ::std::auto_ptr< ::xenc::EncryptionPropertiesType > r (
        ::xsd::cxx::tree::traits< ::xenc::EncryptionPropertiesType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EncryptionProperties",
      "http://www.w3.org/2001/04/xmlenc#");
  }

  ::std::auto_ptr< ::xenc::EncryptionPropertyType >
  EncryptionProperty (const ::std::string& u,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::xenc::EncryptionPropertyType > r (
      ::xenc::EncryptionProperty (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::EncryptionPropertyType >
  EncryptionProperty (const ::std::string& u,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::EncryptionPropertyType > r (
      ::xenc::EncryptionProperty (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::EncryptionPropertyType >
  EncryptionProperty (const ::std::string& u,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::EncryptionPropertyType > r (
      ::xenc::EncryptionProperty (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::EncryptionPropertyType >
  EncryptionProperty (::std::istream& is,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::xenc::EncryptionProperty (isrc, f, p);
  }

  ::std::auto_ptr< ::xenc::EncryptionPropertyType >
  EncryptionProperty (::std::istream& is,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::xenc::EncryptionProperty (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::EncryptionPropertyType >
  EncryptionProperty (::std::istream& is,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::xenc::EncryptionProperty (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::EncryptionPropertyType >
  EncryptionProperty (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::xenc::EncryptionProperty (isrc, f, p);
  }

  ::std::auto_ptr< ::xenc::EncryptionPropertyType >
  EncryptionProperty (::std::istream& is,
                      const ::std::string& sid,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::xenc::EncryptionProperty (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::EncryptionPropertyType >
  EncryptionProperty (::std::istream& is,
                      const ::std::string& sid,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::xenc::EncryptionProperty (isrc, h, f, p);
  }

  ::std::auto_ptr< ::xenc::EncryptionPropertyType >
  EncryptionProperty (::xercesc::InputSource& i,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::xenc::EncryptionPropertyType > r (
      ::xenc::EncryptionProperty (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::EncryptionPropertyType >
  EncryptionProperty (::xercesc::InputSource& i,
                      ::xml_schema::error_handler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::EncryptionPropertyType > r (
      ::xenc::EncryptionProperty (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::EncryptionPropertyType >
  EncryptionProperty (::xercesc::InputSource& i,
                      ::xercesc::DOMErrorHandler& h,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::xenc::EncryptionPropertyType > r (
      ::xenc::EncryptionProperty (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::xenc::EncryptionPropertyType >
  EncryptionProperty (const ::xercesc::DOMDocument& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::xenc::EncryptionPropertyType > r (
        ::xenc::EncryptionProperty (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "EncryptionProperty" &&
        n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
    {
      ::std::auto_ptr< ::xenc::EncryptionPropertyType > r (
        ::xsd::cxx::tree::traits< ::xenc::EncryptionPropertyType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EncryptionProperty",
      "http://www.w3.org/2001/04/xmlenc#");
  }

  ::std::auto_ptr< ::xenc::EncryptionPropertyType >
  EncryptionProperty (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                      ::xml_schema::flags f,
                      const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "EncryptionProperty" &&
        n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
    {
      ::std::auto_ptr< ::xenc::EncryptionPropertyType > r (
        ::xsd::cxx::tree::traits< ::xenc::EncryptionPropertyType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "EncryptionProperty",
      "http://www.w3.org/2001/04/xmlenc#");
  }
}

#include <ostream>
#include <xsd/cxx/xml/dom/serialization-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace xenc
{
  void
  operator<< (::xercesc::DOMElement& e, const EncryptedType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // EncryptionMethod
    //
    if (i.EncryptionMethod ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EncryptionMethod",
          "http://www.w3.org/2001/04/xmlenc#",
          e));

      s << *i.EncryptionMethod ();
    }

    // KeyInfo
    //
    if (i.KeyInfo ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "KeyInfo",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *i.KeyInfo ();
    }

    // CipherData
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "CipherData",
          "http://www.w3.org/2001/04/xmlenc#",
          e));

      s << i.CipherData ();
    }

    // EncryptionProperties
    //
    if (i.EncryptionProperties ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EncryptionProperties",
          "http://www.w3.org/2001/04/xmlenc#",
          e));

      s << *i.EncryptionProperties ();
    }

    // Id
    //
    if (i.Id ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Id",
          e));

      a << *i.Id ();
    }

    // Type
    //
    if (i.Type ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Type",
          e));

      a << *i.Type ();
    }

    // MimeType
    //
    if (i.MimeType ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "MimeType",
          e));

      a << *i.MimeType ();
    }

    // Encoding
    //
    if (i.Encoding ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Encoding",
          e));

      a << *i.Encoding ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const EncryptionMethodType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // KeySize
    //
    if (i.KeySize ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "KeySize",
          "http://www.w3.org/2001/04/xmlenc#",
          e));

      s << *i.KeySize ();
    }

    // OAEPparams
    //
    if (i.OAEPparams ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "OAEPparams",
          "http://www.w3.org/2001/04/xmlenc#",
          e));

      s << *i.OAEPparams ();
    }

    // any
    //
    for (EncryptionMethodType::any_const_iterator
         b (i.any ().begin ()), n (i.any ().end ());
         b != n; ++b)
    {
      e.appendChild (
        e.getOwnerDocument ()->importNode (
          const_cast< ::xercesc::DOMElement* > (&(*b)), true));
    }

    // Algorithm
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Algorithm",
          e));

      a << i.Algorithm ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const KeySizeType& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a,const KeySizeType& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const KeySizeType& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
  }

  void
  CipherData (::std::ostream& o,
              const ::xenc::CipherDataType& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::CipherData (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  CipherData (::std::ostream& o,
              const ::xenc::CipherDataType& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::error_handler& h,
              const ::std::string& e,
              ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::CipherData (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  CipherData (::std::ostream& o,
              const ::xenc::CipherDataType& s,
              const ::xml_schema::namespace_infomap& m,
              ::xercesc::DOMErrorHandler& h,
              const ::std::string& e,
              ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::CipherData (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  CipherData (::xercesc::XMLFormatTarget& t,
              const ::xenc::CipherDataType& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::CipherData (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  CipherData (::xercesc::XMLFormatTarget& t,
              const ::xenc::CipherDataType& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::error_handler& h,
              const ::std::string& e,
              ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::CipherData (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  CipherData (::xercesc::XMLFormatTarget& t,
              const ::xenc::CipherDataType& s,
              const ::xml_schema::namespace_infomap& m,
              ::xercesc::DOMErrorHandler& h,
              const ::std::string& e,
              ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::CipherData (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  CipherData (::xercesc::DOMDocument& d,
              const ::xenc::CipherDataType& s,
              ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "CipherData" &&
        n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CipherData",
        "http://www.w3.org/2001/04/xmlenc#");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  CipherData (const ::xenc::CipherDataType& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::flags f)
  {
    try
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "CipherData",
          "http://www.w3.org/2001/04/xmlenc#",
          m, f));

      ::xenc::CipherData (*d, s, f);
      return d;
    }
    catch (const ::xsd::cxx::xml::dom::mapping< char >& e)
    {
      throw ::xsd::cxx::tree::no_namespace_mapping< char > (e.name ());
    }
    catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
    {
      throw ::xsd::cxx::tree::xsi_already_in_use< char > ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CipherDataType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // CipherValue
    //
    if (i.CipherValue ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "CipherValue",
          "http://www.w3.org/2001/04/xmlenc#",
          e));

      s << *i.CipherValue ();
    }

    // CipherReference
    //
    if (i.CipherReference ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "CipherReference",
          "http://www.w3.org/2001/04/xmlenc#",
          e));

      s << *i.CipherReference ();
    }
  }

  void
  CipherReference (::std::ostream& o,
                   const ::xenc::CipherReferenceType& s,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::CipherReference (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  CipherReference (::std::ostream& o,
                   const ::xenc::CipherReferenceType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xml_schema::error_handler& h,
                   const ::std::string& e,
                   ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::CipherReference (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  CipherReference (::std::ostream& o,
                   const ::xenc::CipherReferenceType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xercesc::DOMErrorHandler& h,
                   const ::std::string& e,
                   ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::CipherReference (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  CipherReference (::xercesc::XMLFormatTarget& t,
                   const ::xenc::CipherReferenceType& s,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::CipherReference (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  CipherReference (::xercesc::XMLFormatTarget& t,
                   const ::xenc::CipherReferenceType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xml_schema::error_handler& h,
                   const ::std::string& e,
                   ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::CipherReference (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  CipherReference (::xercesc::XMLFormatTarget& t,
                   const ::xenc::CipherReferenceType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xercesc::DOMErrorHandler& h,
                   const ::std::string& e,
                   ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::CipherReference (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  CipherReference (::xercesc::DOMDocument& d,
                   const ::xenc::CipherReferenceType& s,
                   ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "CipherReference" &&
        n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CipherReference",
        "http://www.w3.org/2001/04/xmlenc#");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  CipherReference (const ::xenc::CipherReferenceType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xml_schema::flags f)
  {
    try
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "CipherReference",
          "http://www.w3.org/2001/04/xmlenc#",
          m, f));

      ::xenc::CipherReference (*d, s, f);
      return d;
    }
    catch (const ::xsd::cxx::xml::dom::mapping< char >& e)
    {
      throw ::xsd::cxx::tree::no_namespace_mapping< char > (e.name ());
    }
    catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
    {
      throw ::xsd::cxx::tree::xsi_already_in_use< char > ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CipherReferenceType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Transforms
    //
    if (i.Transforms ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Transforms",
          "http://www.w3.org/2001/04/xmlenc#",
          e));

      s << *i.Transforms ();
    }

    // URI
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "URI",
          e));

      a << i.URI ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TransformsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Transform
    //
    for (TransformsType::Transform_const_iterator
         b (i.Transform ().begin ()), n (i.Transform ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Transform",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *b;
    }
  }

  void
  EncryptedData (::std::ostream& o,
                 const ::xenc::EncryptedDataType& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::EncryptedData (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  EncryptedData (::std::ostream& o,
                 const ::xenc::EncryptedDataType& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::error_handler& h,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::EncryptedData (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EncryptedData (::std::ostream& o,
                 const ::xenc::EncryptedDataType& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xercesc::DOMErrorHandler& h,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::EncryptedData (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EncryptedData (::xercesc::XMLFormatTarget& t,
                 const ::xenc::EncryptedDataType& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::EncryptedData (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  EncryptedData (::xercesc::XMLFormatTarget& t,
                 const ::xenc::EncryptedDataType& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::error_handler& h,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::EncryptedData (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EncryptedData (::xercesc::XMLFormatTarget& t,
                 const ::xenc::EncryptedDataType& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xercesc::DOMErrorHandler& h,
                 const ::std::string& e,
                 ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::EncryptedData (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EncryptedData (::xercesc::DOMDocument& d,
                 const ::xenc::EncryptedDataType& s,
                 ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "EncryptedData" &&
        n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "EncryptedData",
        "http://www.w3.org/2001/04/xmlenc#");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  EncryptedData (const ::xenc::EncryptedDataType& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::flags f)
  {
    try
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "EncryptedData",
          "http://www.w3.org/2001/04/xmlenc#",
          m, f));

      ::xenc::EncryptedData (*d, s, f);
      return d;
    }
    catch (const ::xsd::cxx::xml::dom::mapping< char >& e)
    {
      throw ::xsd::cxx::tree::no_namespace_mapping< char > (e.name ());
    }
    catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
    {
      throw ::xsd::cxx::tree::xsi_already_in_use< char > ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const EncryptedDataType& i)
  {
    e << static_cast< const ::xenc::EncryptedType& > (i);
  }

  void
  EncryptedKey (::std::ostream& o,
                const ::xenc::EncryptedKeyType& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::EncryptedKey (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  EncryptedKey (::std::ostream& o,
                const ::xenc::EncryptedKeyType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xml_schema::error_handler& h,
                const ::std::string& e,
                ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::EncryptedKey (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EncryptedKey (::std::ostream& o,
                const ::xenc::EncryptedKeyType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xercesc::DOMErrorHandler& h,
                const ::std::string& e,
                ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::EncryptedKey (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EncryptedKey (::xercesc::XMLFormatTarget& t,
                const ::xenc::EncryptedKeyType& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::EncryptedKey (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  EncryptedKey (::xercesc::XMLFormatTarget& t,
                const ::xenc::EncryptedKeyType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xml_schema::error_handler& h,
                const ::std::string& e,
                ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::EncryptedKey (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EncryptedKey (::xercesc::XMLFormatTarget& t,
                const ::xenc::EncryptedKeyType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xercesc::DOMErrorHandler& h,
                const ::std::string& e,
                ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::EncryptedKey (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EncryptedKey (::xercesc::DOMDocument& d,
                const ::xenc::EncryptedKeyType& s,
                ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "EncryptedKey" &&
        n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "EncryptedKey",
        "http://www.w3.org/2001/04/xmlenc#");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  EncryptedKey (const ::xenc::EncryptedKeyType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xml_schema::flags f)
  {
    try
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "EncryptedKey",
          "http://www.w3.org/2001/04/xmlenc#",
          m, f));

      ::xenc::EncryptedKey (*d, s, f);
      return d;
    }
    catch (const ::xsd::cxx::xml::dom::mapping< char >& e)
    {
      throw ::xsd::cxx::tree::no_namespace_mapping< char > (e.name ());
    }
    catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
    {
      throw ::xsd::cxx::tree::xsi_already_in_use< char > ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const EncryptedKeyType& i)
  {
    e << static_cast< const ::xenc::EncryptedType& > (i);

    // ReferenceList
    //
    if (i.ReferenceList ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ReferenceList",
          "http://www.w3.org/2001/04/xmlenc#",
          e));

      s << *i.ReferenceList ();
    }

    // CarriedKeyName
    //
    if (i.CarriedKeyName ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "CarriedKeyName",
          "http://www.w3.org/2001/04/xmlenc#",
          e));

      s << *i.CarriedKeyName ();
    }

    // Recipient
    //
    if (i.Recipient ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Recipient",
          e));

      a << *i.Recipient ();
    }
  }

  void
  AgreementMethod (::std::ostream& o,
                   const ::xenc::AgreementMethodType& s,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::AgreementMethod (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  AgreementMethod (::std::ostream& o,
                   const ::xenc::AgreementMethodType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xml_schema::error_handler& h,
                   const ::std::string& e,
                   ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::AgreementMethod (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  AgreementMethod (::std::ostream& o,
                   const ::xenc::AgreementMethodType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xercesc::DOMErrorHandler& h,
                   const ::std::string& e,
                   ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::AgreementMethod (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  AgreementMethod (::xercesc::XMLFormatTarget& t,
                   const ::xenc::AgreementMethodType& s,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::string& e,
                   ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::AgreementMethod (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  AgreementMethod (::xercesc::XMLFormatTarget& t,
                   const ::xenc::AgreementMethodType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xml_schema::error_handler& h,
                   const ::std::string& e,
                   ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::AgreementMethod (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  AgreementMethod (::xercesc::XMLFormatTarget& t,
                   const ::xenc::AgreementMethodType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xercesc::DOMErrorHandler& h,
                   const ::std::string& e,
                   ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::AgreementMethod (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  AgreementMethod (::xercesc::DOMDocument& d,
                   const ::xenc::AgreementMethodType& s,
                   ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "AgreementMethod" &&
        n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "AgreementMethod",
        "http://www.w3.org/2001/04/xmlenc#");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  AgreementMethod (const ::xenc::AgreementMethodType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xml_schema::flags f)
  {
    try
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "AgreementMethod",
          "http://www.w3.org/2001/04/xmlenc#",
          m, f));

      ::xenc::AgreementMethod (*d, s, f);
      return d;
    }
    catch (const ::xsd::cxx::xml::dom::mapping< char >& e)
    {
      throw ::xsd::cxx::tree::no_namespace_mapping< char > (e.name ());
    }
    catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
    {
      throw ::xsd::cxx::tree::xsi_already_in_use< char > ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AgreementMethodType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // KA-Nonce
    //
    if (i.KA_Nonce ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "KA-Nonce",
          "http://www.w3.org/2001/04/xmlenc#",
          e));

      s << *i.KA_Nonce ();
    }

    // any
    //
    for (AgreementMethodType::any_const_iterator
         b (i.any ().begin ()), n (i.any ().end ());
         b != n; ++b)
    {
      e.appendChild (
        e.getOwnerDocument ()->importNode (
          const_cast< ::xercesc::DOMElement* > (&(*b)), true));
    }

    // OriginatorKeyInfo
    //
    if (i.OriginatorKeyInfo ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "OriginatorKeyInfo",
          "http://www.w3.org/2001/04/xmlenc#",
          e));

      s << *i.OriginatorKeyInfo ();
    }

    // RecipientKeyInfo
    //
    if (i.RecipientKeyInfo ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "RecipientKeyInfo",
          "http://www.w3.org/2001/04/xmlenc#",
          e));

      s << *i.RecipientKeyInfo ();
    }

    // Algorithm
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Algorithm",
          e));

      a << i.Algorithm ();
    }
  }

  void
  ReferenceList_ (::std::ostream& o,
                  const ::xenc::ReferenceList& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::ReferenceList_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  ReferenceList_ (::std::ostream& o,
                  const ::xenc::ReferenceList& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::error_handler& h,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::ReferenceList_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ReferenceList_ (::std::ostream& o,
                  const ::xenc::ReferenceList& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xercesc::DOMErrorHandler& h,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::ReferenceList_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ReferenceList_ (::xercesc::XMLFormatTarget& t,
                  const ::xenc::ReferenceList& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::ReferenceList_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  ReferenceList_ (::xercesc::XMLFormatTarget& t,
                  const ::xenc::ReferenceList& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::error_handler& h,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::ReferenceList_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ReferenceList_ (::xercesc::XMLFormatTarget& t,
                  const ::xenc::ReferenceList& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xercesc::DOMErrorHandler& h,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::ReferenceList_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ReferenceList_ (::xercesc::DOMDocument& d,
                  const ::xenc::ReferenceList& s,
                  ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ReferenceList" &&
        n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ReferenceList",
        "http://www.w3.org/2001/04/xmlenc#");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  ReferenceList_ (const ::xenc::ReferenceList& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::flags f)
  {
    try
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "ReferenceList",
          "http://www.w3.org/2001/04/xmlenc#",
          m, f));

      ::xenc::ReferenceList_ (*d, s, f);
      return d;
    }
    catch (const ::xsd::cxx::xml::dom::mapping< char >& e)
    {
      throw ::xsd::cxx::tree::no_namespace_mapping< char > (e.name ());
    }
    catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
    {
      throw ::xsd::cxx::tree::xsi_already_in_use< char > ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReferenceType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // any
    //
    for (ReferenceType::any_const_iterator
         b (i.any ().begin ()), n (i.any ().end ());
         b != n; ++b)
    {
      e.appendChild (
        e.getOwnerDocument ()->importNode (
          const_cast< ::xercesc::DOMElement* > (&(*b)), true));
    }

    // URI
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "URI",
          e));

      a << i.URI ();
    }
  }

  void
  EncryptionProperties (::std::ostream& o,
                        const ::xenc::EncryptionPropertiesType& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::EncryptionProperties (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  EncryptionProperties (::std::ostream& o,
                        const ::xenc::EncryptionPropertiesType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::error_handler& h,
                        const ::std::string& e,
                        ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::EncryptionProperties (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EncryptionProperties (::std::ostream& o,
                        const ::xenc::EncryptionPropertiesType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xercesc::DOMErrorHandler& h,
                        const ::std::string& e,
                        ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::EncryptionProperties (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EncryptionProperties (::xercesc::XMLFormatTarget& t,
                        const ::xenc::EncryptionPropertiesType& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::string& e,
                        ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::EncryptionProperties (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  EncryptionProperties (::xercesc::XMLFormatTarget& t,
                        const ::xenc::EncryptionPropertiesType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::error_handler& h,
                        const ::std::string& e,
                        ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::EncryptionProperties (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EncryptionProperties (::xercesc::XMLFormatTarget& t,
                        const ::xenc::EncryptionPropertiesType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xercesc::DOMErrorHandler& h,
                        const ::std::string& e,
                        ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::EncryptionProperties (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EncryptionProperties (::xercesc::DOMDocument& d,
                        const ::xenc::EncryptionPropertiesType& s,
                        ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "EncryptionProperties" &&
        n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "EncryptionProperties",
        "http://www.w3.org/2001/04/xmlenc#");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  EncryptionProperties (const ::xenc::EncryptionPropertiesType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::flags f)
  {
    try
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "EncryptionProperties",
          "http://www.w3.org/2001/04/xmlenc#",
          m, f));

      ::xenc::EncryptionProperties (*d, s, f);
      return d;
    }
    catch (const ::xsd::cxx::xml::dom::mapping< char >& e)
    {
      throw ::xsd::cxx::tree::no_namespace_mapping< char > (e.name ());
    }
    catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
    {
      throw ::xsd::cxx::tree::xsi_already_in_use< char > ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const EncryptionPropertiesType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // EncryptionProperty
    //
    for (EncryptionPropertiesType::EncryptionProperty_const_iterator
         b (i.EncryptionProperty ().begin ()), n (i.EncryptionProperty ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EncryptionProperty",
          "http://www.w3.org/2001/04/xmlenc#",
          e));

      s << *b;
    }

    // Id
    //
    if (i.Id ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Id",
          e));

      a << *i.Id ();
    }
  }

  void
  EncryptionProperty (::std::ostream& o,
                      const ::xenc::EncryptionPropertyType& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::EncryptionProperty (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  EncryptionProperty (::std::ostream& o,
                      const ::xenc::EncryptionPropertyType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::error_handler& h,
                      const ::std::string& e,
                      ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::EncryptionProperty (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EncryptionProperty (::std::ostream& o,
                      const ::xenc::EncryptionPropertyType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xercesc::DOMErrorHandler& h,
                      const ::std::string& e,
                      ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::EncryptionProperty (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EncryptionProperty (::xercesc::XMLFormatTarget& t,
                      const ::xenc::EncryptionPropertyType& s,
                      const ::xml_schema::namespace_infomap& m,
                      const ::std::string& e,
                      ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::EncryptionProperty (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  EncryptionProperty (::xercesc::XMLFormatTarget& t,
                      const ::xenc::EncryptionPropertyType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::error_handler& h,
                      const ::std::string& e,
                      ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::EncryptionProperty (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EncryptionProperty (::xercesc::XMLFormatTarget& t,
                      const ::xenc::EncryptionPropertyType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xercesc::DOMErrorHandler& h,
                      const ::std::string& e,
                      ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xenc::EncryptionProperty (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  EncryptionProperty (::xercesc::DOMDocument& d,
                      const ::xenc::EncryptionPropertyType& s,
                      ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "EncryptionProperty" &&
        n.namespace_ () == "http://www.w3.org/2001/04/xmlenc#")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "EncryptionProperty",
        "http://www.w3.org/2001/04/xmlenc#");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  EncryptionProperty (const ::xenc::EncryptionPropertyType& s,
                      const ::xml_schema::namespace_infomap& m,
                      ::xml_schema::flags f)
  {
    try
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "EncryptionProperty",
          "http://www.w3.org/2001/04/xmlenc#",
          m, f));

      ::xenc::EncryptionProperty (*d, s, f);
      return d;
    }
    catch (const ::xsd::cxx::xml::dom::mapping< char >& e)
    {
      throw ::xsd::cxx::tree::no_namespace_mapping< char > (e.name ());
    }
    catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
    {
      throw ::xsd::cxx::tree::xsi_already_in_use< char > ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const EncryptionPropertyType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // any_attribute
    //
    for (EncryptionPropertyType::any_attribute_const_iterator
         b (i.any_attribute ().begin ()), n (i.any_attribute ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMAttr* a (
        static_cast< ::xercesc::DOMAttr* > (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

      if (a->getLocalName () == 0)
        e.setAttributeNode (a);
      else
        e.setAttributeNodeNS (a);
    }

    // any
    //
    for (EncryptionPropertyType::any_const_iterator
         b (i.any ().begin ()), n (i.any ().end ());
         b != n; ++b)
    {
      e.appendChild (
        e.getOwnerDocument ()->importNode (
          const_cast< ::xercesc::DOMElement* > (&(*b)), true));
    }

    // Target
    //
    if (i.Target ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Target",
          e));

      a << *i.Target ();
    }

    // Id
    //
    if (i.Id ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Id",
          e));

      a << *i.Id ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReferenceList& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // DataReference
    //
    for (ReferenceList::DataReference_const_iterator
         b (i.DataReference ().begin ()), n (i.DataReference ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DataReference",
          "http://www.w3.org/2001/04/xmlenc#",
          e));

      s << *b;
    }

    // KeyReference
    //
    for (ReferenceList::KeyReference_const_iterator
         b (i.KeyReference ().begin ()), n (i.KeyReference ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "KeyReference",
          "http://www.w3.org/2001/04/xmlenc#",
          e));

      s << *b;
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

