#!/usr/bin/env python
#
# This script tries to strip down an existing filesystem image.
#
# Usage: xbe-create-image [-d|-i image|-b blacklist|-t template...] src-dir dst-dir
#    -d       output debug information
#    -i image generate a filesystem image from dst-dir
#    -b blist black list of regular expressions that define paths to not include in the resulting image
#
# The "image" file may be proceeded with the filesystem-type to use:
#    ext2:/tmp/foo.img and so on
# effectively, mkfs.<fs-type> will be called. The default is ext2.
#
# Overall procedure:
#   The script relies on an existing and working linux installation in some
#   directory (defined by src-dir), this maybe the root of the host environment
#   or some other path, problems exist, when different architectures are used,
#   of course.
#
#   The steps are as follows:
#     Take all files and directories from the given template files and check
#     them against the blacklist. If they are not blacklisted, continue,
#     otherwise take the next entry.
#
#        With the non-blacklisted items:
#           evaluate the dependencies heuristic (currently this is a
#           combination of 'ldd' and 'strings')
#
#           copy the resulting list of elements to the target directory
#
#   - Finally create required directories, if they do not already exist:
#       /proc, /sys, /dev
#   - Fill /dev with some always required device nodes.
#   - Copy in a small init script that does nothing more than setting up the
#     network (dhcp), starts an ssh daemon (if available) and eventually boots up
#     the xbeinstd.
#   
# Known limitations:
#   
# 
import os, os.path, sys
import re
from subprocess import Popen, PIPE
from xbe.util import disk
from exceptions import RuntimeError

debug = True

# exit codes
EXIT_SUCCESS = 0
EXIT_FAILURE = 1
EXIT_UNRESOLVED_DEP = 8

if debug:
    def trace(fmt, *args):
        print >>sys.stderr, "*** DBG:", fmt % args
else:
    def trace(fmt, *args):
        pass

def runcmd(cmd, *args, **kw):
    pipe = Popen(cmd, stdout=PIPE, stderr=PIPE, close_fds=True, *args, **kw)
    (stdout, stderr) = pipe.communicate()
    exitcode = pipe.wait()
    return (exitcode, stdout.split("\n"), stderr.split("\n"))

class AmbiguousPath(RuntimeError):
    def __init__(self, path, resolved_paths):
        RuntimeError.__init__(self)
        self.path = path
        self.resolved_paths = resolved_paths

class PathBlacklisted(RuntimeError):
    def __init__(self, path):
        RuntimeError.__init__(self)
        self.path = path

class PathResolver:
    def __init__(self, blacklist):
        self.__blacklist = blacklist
        self.__paths = []

    def add(self, p):
        self.__paths.append(p)

    def resolve(self, path, pathFilter=None):
        """Checks whether the given path exists according to one of the root paths."""
        if pathFilter is None:
            pathFilter = lambda x: True
        resolved_paths = []
        for root in self.__paths:
            normalized_path = os.path.normpath(path).lstrip("/")
            normalized_path = os.path.join(root, normalized_path)
            if os.path.exists(normalized_path) and not self.__blacklist(normalized_path) and pathFilter(normalized_path):
                resolved_paths.append(normalized_path)
        if len(resolved_paths) > 1:
            raise AmbiguousPath(path, resolved_paths)
        elif len(resolved_paths) == 1:
            return Path(resolved_paths[0], path)
        else:
            raise PathBlacklisted(path)

class PreorderVisitor:
    def __init__(self, F):
        self.__fun = F

    def __call__(self, node):
        self.__fun(node)
        for c in node.get_dependencies():
            self(c)

class Path:
    def __init__(self, src_path, dst_path):
        self.__src = src_path      # the one on the local filesystem, resolved by the path resolver
        self.__dst = dst_path # where it shall be copied to in the destination fs, read from a template

    def src(self):
        return self.__src
    def dst(self):
        return self.__dst

    def __str__(self):
        return self.src()

class DependencyNode:
    def __init__(self, path, type="str", parent=None, blacklist=None, max_depth=None):
        self.__path = path
        self.__type = type # str dep, or ldd dep
        self.__parent = parent
        if parent is not None:
            self.__depth = parent.get_depth() + 1
        else:
            self.__depth = 0
        if blacklist is None and parent is not None:
            self.__blacklist = parent.get_blacklist()
        else:
            self.__blacklist = blacklist
        if max_depth is None and parent is not None:
            self.__max_depth = parent.max_depth()
        else:
            self.__max_depth = max_depth or 5
        self.__dependencies = []

    def path(self):
        return self.__path

    def get_depth(self):
        return self.__depth
    def set_depth(self, d):
        self.__depth = d
    def get_blacklist(self):
        return self.__blacklist

    def max_depth(self):
        return self.__max_depth

#    def _blacklisted(self, p):
#        if self.__blacklist is not None:
#            return self.__blacklist(p)
#        else:
#            return False

    def apply(self, visitor):
        visitor(self)

    def get_child_count(self):
        class F:
            def __init__(self):
                self.count = 0
            def __call__(self, notused):
                self.count = self.count + 1
        Counter = F()
        self.apply(PreorderVisitor(Counter))
        return Counter.count

    def get_dependencies(self):
        return self.__dependencies

    def weight(self):
        pass
    def get_root(self):
        if self.__parent is None:
            return self
        return self.__parent.get_root()

    def contains_dependency(self, p):
        if self.path() is not None and self.path().dst() == p:
            return True
        for d in self.__dependencies:
            if d.contains_dependency(p):
                return True
        return False

    def add(self, child):
        self.__dependencies.append(child)

    def resolve_dependencies(self, path_resolver, depth=0):
        if self.path() is None:
            return

        # always resolve symlinks
        self._resolve_symlinks(path_resolver, depth)
        # if the file is executable, resolve libraries as well
        if os.access(self.path().src(), os.X_OK):
            self._resolve_ldd_deps(path_resolver, depth)

        # resolve string dependencies only up to the given max depth
        if depth >= self.max_depth():
            return
        self._resolve_str_deps(path_resolver, depth)

    def _resolve_ldd_deps(self, path_resolver, depth=0):
        trace("getting ldd deps for %s (%d)", self.path(), depth)
        exitcode, output, _ = runcmd(["ldd", self.path().src()])
        if exitcode == 0:
            for line in output:
                line = line.strip()
                if not len(line): continue
                if line == "statically linked": continue
                dependency=None
                if '=>' in line:
                    dependency=line.split()[2]
                else:
                    dependency=line.split()[0]
                try:
                    resolved_dependency = path_resolver.resolve(dependency)
                    if not self.get_root().contains_dependency(dependency):
                        trace("ldd dependency: %s", dependency)
                        child = DependencyNode(resolved_dependency, "ldd", self)
                        self.add(child)
                        child.resolve_dependencies(path_resolver, depth+1)
                except PathBlacklisted:
                    pass
        trace("done")

    def _resolve_str_deps(self, path_resolver, depth=0):
        trace("getting str deps for %s (%d)", self.path(), depth)
        # extract "absolute paths" from the file
        regexp = re.compile('[^/]*([/][^ :;)"]+)+')
        (exitcode, output, _) = runcmd(["strings", self.path().src()])
        if exitcode == 0:
            for line in output:
                match = regexp.match(line)
                if match and len(match.groups()):
                    dependency = match.group(1).strip()
                    try:
                        resolved_dependency = path_resolver.resolve(dependency, os.path.isfile)
                        if not self.get_root().contains_dependency(dependency):
                            trace("str dependency: %s", dependency)
                            child = DependencyNode(resolved_dependency, "str", self)
                            self.add(child)
                            child.resolve_dependencies(path_resolver, depth+1)
                    except PathBlacklisted:
                        pass
        trace(" "*depth + "done")

    def _resolve_symlinks_helper(self, p, path_resolver):
        links = []
        if os.path.islink(p.src()):
            link = os.readlink(p.src())

            # make it absolute
            if not os.path.isabs(link):
                link = os.path.join(os.path.dirname(p.src()), link)
            link = path_resolver.resolve(link)
            links.append(link)
            links.extend(self._resolve_symlinks_helper(link, path_resolver))
        return links

    def _resolve_symlinks(self, path_resolver, depth=0):
        trace("resolving symlinks of %s", self.path())
        links = self._resolve_symlinks_helper(self.path(), path_resolver)
        for link in links:
            child = DependencyNode(link, "sym", self)
            self.add(child)
            child.resolve_dependencies(path_resolver, depth+1)

    def getFileType(self):
        if self.path() is None: return "n/a"
        f = self.path().src()
        if os.path.isfile(f): return "file"
        if os.path.isdir(f): return "dir"
        if os.path.islink(f): return "file"
        return "n/a"

    def toString(self, depth=0):
        name = "<root>"
        if self.path() is not None:
            name = "%s (-> %s)" % (self.path().src(), self.path().dst())
        s = ["\t"*depth + name + " (%d, %s, %s)" % (self.get_depth(), self.__type, self.getFileType())]
        for d in self.__dependencies:
            s.append(d.toString(depth+1))
        return "\n".join(s)

    def __str__(self):
        return self.toString(-1)

class DependencyScanner:
    def __init__(self, path_resolver, template, blacklist, max_depth):
        self.__path_resolver = path_resolver
        self.__template = template
        self.__blacklist = blacklist
        self.__max_depth = max_depth

    def run(self):
        root = DependencyNode(None, "root", None, self.__blacklist, self.__max_depth+1)
        root.set_depth(-1)
        for f in self.__template:
            path = self.__path_resolver.resolve(f)
            node = DependencyNode(path, "tpl", root)
            root.add(node)
            node.resolve_dependencies(self.__path_resolver)
        return root

class ImageCreator:
    def __init__(self, src, dst, heuristic, options):
        self.__src = src
        self.__dst = dst
        self.__heuristic = heuristic
        self.__options = options

    def run(self, templates, blacklist=None, filters=(None,None)):
        failed_deps=[]
        for T in templates:
            for f in T:
                deps = self.__heuristic.run(f, blacklist)
                if blacklist is not None:
                    deps = filter(lambda x: not blacklist(x), deps)
                for d in deps:
                    result, path = self.copy_file(d, filters[0], filters[1])
                    if result == 1:
                        failed_deps.append(path)
        return failed_deps

    def copy_file(self, file, before_filter=None, after_filter=None):
        # get the directory that contains the original file
        # relative to the root directory
        (drive, src_dir) = os.path.splitdrive(os.path.dirname(file))
        relative_src_dir = src_dir.lstrip(os.path.sep)
        if before_filter is not None:
            if self.__options.dry_run:
                trace("Running before filter on '%s'", file)
            else:
                file = before_filter(file)

        # the actual file name
        file_name = os.path.basename(file)

        # copy the file to the destination directory
        dst_path = os.path.join(self.__dst, relative_src_dir)
        # makedirs
        if not os.path.exists(dst_path):
            if self.__options.dry_run:
                trace("Creating directory: %s", dst_path)
            else:
                os.makedirs(dst_path)
        dst_file = os.path.join(dst_path, file_name)
        if not os.path.exists(dst_file):
            exitcode, out, err = 0, "", ""
            if self.__options.dry_run:
                trace("Copying '%s' -> '%s'", file, dst_file)
            else:
                exitcode, out, err = runcmd(["cp", "-aP", file, dst_file])
            if exitcode == 0:
                if after_filter is not None:
                    if self.__options.dry_run:
                        trace("Running before filter on '%s'", file)
                    else:
                        after_filter(dst_file)
            else:
                trace("copy '%s' -> '%s' failed: out: '%s', err: '%s'", file, dst_file, out, err) 
                return (1, file)
        else:
            #trace("destination path '%s' does already exist!", dst_file)
            pass
        return (0, file)

    def parseImageURI(self, image_uri, default_type="ext2"):
        colon_index = image_uri.find(":")
        if colon_index != -1:
            image_type = image_uri[0:colon_index]
            image_path = image_uri[colon_index+1:]
            return (image_type, image_path)
        return (default_type, image_uri)

    def createFSImage(self, image_uri, appDataSpace=0, bonusSpacePercent=0.01):
        """Create the filesystem image at 'image_path' with fs-type 'image_type'.

        The 'appDataSpace' is a fixed amount of #bytes to reserve within the image for future application data.
        The 'bonusSpacePercent' (0 <= p <= 1) will be added to the sum of required space + application data.
        """
        image_type, image_path = self.parseImageURI(image_uri)
        image_size = int(round( (self.getRequiredSpace() + appDataSpace) * (1 + bonusSpacePercent)))
        try:
            disk.makeSparseDisk(image_path, image_size / (1024**2))
            # format the image with the given fs-type
            exitcode, output, errout = runcmd(["mkfs.%s" % image_type, "-F", image_path])
            if exitcode != 0:
                trace("could not create filesystem '%s' on '%s': %s", image_type, image_path, errout)
                raise RuntimeError("filesystem creation failed")
        except:
            trace("could not create image at path: %s", image_path)
            raise
        image = disk.Image(image_path, image_type)

        # the following step requires root priviledges
        mount_point = image.mount()

        # copy everything into the image while preserving their access rights
        trace("filling the image")
        for e in os.listdir(self.__dst):
            exitcode, out, err = runcmd(["cp", "-a", os.path.join(self.__dst, e), mount_point])

        image.umount()

    def getRequiredSpace(self):
        result = 0
        for root, subdirs, files in os.walk(self.__dst):
            files = filter(lambda x: not os.path.islink(x), files)
            result += sum(os.path.getsize(os.path.join(root, name)) for name in files)
        return result
    
class StripFilter:
    def __init__(self):
        pass

    def __call__(self, path):
        if os.access(path, os.X_OK):
            runcmd(["strip", "--strip-unneeded", path])
        return path

class Blacklist:
    def __init__(self):
        self.__blacklist = []

    def __call__(self, path):
        return self.is_blacklisted(path)

    def is_blacklisted(self, path):
        for pattern, regexp in self.__blacklist:
            found_match=False
            try:
                found_match=(regexp.match(path) is not None)
            except:
                pass
            if found_match:
                trace("Dependency '%s' blacklisted due to pattern '%s'", path, pattern)
                return True
        return False

    def add(self, item):
        try:
            self.__blacklist.append( (item, re.compile(item)) )
        except:
            trace("could not add pattern: '%s'", item)

    @classmethod
    def from_file(cls, path, bl=None):
        """Create a blacklist from the entries found in a file.

        The extra argument "bl" can be used to extend a previously created blacklist.
        
        The file needs to be formatted as follows:
            Each line contains either a valid regular expression (in terms of Python regexps) or
            is an empty line or starts with an # which is interpreted as a comment.
        """

        # create a new blacklist if none is given
        if bl == None:
            bl = cls()
        try:
            F = open(path, "r")
            for line in F:
                line=line.strip()
                if line.startswith("#"): continue
                if not len(line): continue
                trace("Adding pattern '%s' to blacklist.", line)
                bl.add(line)                
        except IOError, ioe:
            print >>sys.stderr, "E: Could not open `%s' for reading: %s" % (path, ioe)
        except:
            print >>sys.stderr, "E: Could not open `%s' for reading!" % (path)
        return bl

class ImageTemplate:
    """This class defines the contents of the generated image."""

    def __init__(self):
        self.__items = []

    def __iter__(self):
        return self.__items.__iter__()

    def add(self, item):
        self.__items.append(item)

    @classmethod
    def from_file(cls, path, template=None):
        """Create a template from the entries found in a file.

        The extra argument "template" can be used to extend an existing
        template instead of creating a new one.
        """

        # create a new template if None is given
        if template == None:
            template = cls()
        try:
            F = open(path, "r")
            for line in F:
                line=line.strip()
                if line.startswith("#"): continue
                if not len(line): continue
                trace("Adding template entry '%s' to template.", line)
                template.add(line)                
        except IOError, ioe:
            print >>sys.stderr, "E: Could not open `%s' for reading: %s" % (path, ioe)
        except:
            print >>sys.stderr, "E: Could not open `%s' for reading!" % (path)
        return template

def main():
    from optparse import OptionParser
    parser = OptionParser(usage="usage: %prog [options] src dst")
    parser.add_option("-d", "--debug", action="store_true", dest="debug", default=False, help="print debug information")
    parser.add_option("-n", "--dry-run", action="store_true", dest="dry_run", default=False, help="don't perform any action, just print what would have been done")
    parser.add_option("--max-depth", dest="max_depth", type="int", default=4, help="traverse dependency tree up to this depth")
    parser.add_option("-i", "--image", dest="image", help="create an image from the generated directory")
    parser.add_option("-b", "--blacklist", dest="blacklists", type="string", action="append", help="add a blacklist")
    parser.add_option("-t", "--template", dest="templates", type="string", action="append", help="add a template")
    parser.add_option("-s", "--appdata-size", dest="appdata_size", type="int", default=0, help="additional space to reserve for application data in bytes")
    parser.add_option("-p", "--bonus-percent", dest="bonus_percent", type="float", default=0.0, help="additional space (in percent) to reserve within the image")

    (options, args) = parser.parse_args()

    if len(args) < 2:
        print >>sys.stderr, "src and/or destination parameters are missing"
        print >>sys.stderr, "  try `%s --help' for help" % sys.argv[0]
        sys.exit(EXIT_FAILURE)
    (src, dst) = args[:2]

#    dh = DependencyHeuristic(src)
#    ic = ImageCreator(src, dst, dh, options)

    template = ImageTemplate()
    for path in options.templates:
        template = ImageTemplate.from_file(path, template)

    blacklist = Blacklist()
    for path in options.blacklists:
        blacklist = Blacklist.from_file(path, blacklist)

    resolver = PathResolver(blacklist)
    resolver.add(src)

    scanner = DependencyScanner(resolver, template, blacklist, options.max_depth)
    root = scanner.run()
    print root
    print "number of nodes:", root.get_child_count()
#
#    failed = ic.run(templates, blacklist, (None, StripFilter()))
#    if len(failed):
#        print >>sys.stderr, "failed dependencies:", failed
#    if options.image is not None:
#        ic.createFSImage(options.image, options.appdata_size, options.bonus_percent / 100.0)
#    print "The FS consumes %d MB" % (ic.getRequiredSpace() / (1024**2))
    sys.exit(EXIT_SUCCESS)

if __name__ == "__main__":
    main()

