#!/usr/bin/env python

"""Xen based execution environment (XBE) commandline tool.

usage: xbe <subcommand> [options] [args]
Version: $Revision$
Author: Alexander Petry <petry@itwm.fhg.de>

Type 'xbe help <subcommand>' for help on a specific subcommand.
"""

from xbe.util.uuid import uuid

from twisted.internet import reactor, defer
from twisted.internet.protocol import ClientCreator
from xbe.stomp.proto import StompClientFactory, StompClient, reason as StompErrorReason

import logging, sys, re, os
log = logging.getLogger(__name__)

from optparse import OptionParser
from textwrap import dedent

from xbe.xml import xsdl
from lxml import etree

URI_PATTERN = r'((?P<prot>[a-zA-Z]+)://)?(?P<path>.*)'

class NoPrintOptionParser(OptionParser):
    def __init__(self, usage=None, add_help_option=True):
        OptionParser.__init__(self,usage=usage, add_help_option=add_help_option, prog="")
    def error(self, msg):
        raise CommandFailed(msg)

class CommandFailed(Exception):
    pass

class UnknownCommand(Exception):
    pass

def parse_args_stderr_hack(parser, argv):
    try:
        # WARNIG: hack to avoid printing to stderr
        stderr_hack = sys.stderr

        from StringIO import StringIO
        sys.stderr = StringIO()

        options, args = parser.parse_args(argv)
        sys.stderr = stderr_hack
    except:
        msg, sys.stderr = sys.stderr, stderr_hack
        msg.seek(0)
        lines = [ l.strip() for l in msg.readlines()[2:] ]
        raise CommandFailed("\n".join(lines))
    return (options, args)

def parse_args_normal(parser, argv):
    return parser.parse_args(argv)
parse_args = parse_args_normal
    

class Command(object):
    """The base class for commands."""

    def execute(self):
        """run the specified command."""
        raise RuntimeError("can't execute the base Command.")

    def executeFailed(self, exception):
        self.failed = (True, exception)

    def __init__(self, argv):
        """initialize the command.

        argv -- the arguments passed to this command.

        """

        self.failed = (False, '')
        self.name = argv[0]
        self.argv = argv[1:]

        p = NoPrintOptionParser(usage="usage: %s [options]" % self.name, add_help_option=False)
        p.add_option("-H", "--host", dest="host", type="string",
                     default="xen-o-matic.itwm.fhrg.fraunhofer.de", help="STOMP server to use")
        p.add_option("-P", "--port", dest="port", type="int",    default=61613, help="STOMP server to use")

        self.parser = p

    def buildHelp(self):
        from StringIO import StringIO
        help_file = StringIO()
        self.parser.print_help(help_file)
        help_file.seek(0)
        lines = help_file.readlines()[2:]
        self.__doc__ += "".join(lines)

    def __str__(self):
        return self.name

class RemoteCommand(Command):
    def __init__(self, argv):
        """Initialize some common options for remote commands."""
        Command.__init__(self, argv)
        p = self.parser
        p.add_option("-u", "--username", dest="user",  type="string", help="the username to use")
        p.add_option("-p", "--password", dest="pass",  type="string", help="the password to use")
        p.add_option("-t", "--timeout", dest="timeout", type="int", default=5, help="time to wait for an answer from server")
        p.add_option("--cert", dest="cert",  type="string", help="the certificate to use")
        
    def handleMessage(self, msg):
        """handles the given message from the STOMP server."""
        xml = etree.fromstring(msg.body)
        if xml[0].tag == xsdl.Tag("Error"):
            self._handleError(xml[0])
        else:
            self._handleMessage(xml[0])
            reactor.stop()

    def _handleError(self, err):
        errcode = int(err.findtext(xsdl.XSDL("ErrorCode")))
        errname = err.findtext(xsdl.XSDL("ErrorName"))
        errmsg  = err.findtext(xsdl.XSDL("ErrorMessage"))
        if errcode != 200:
            raise CommandFailed("[Code %d]: %s - %s" % (errcode, errname, errmsg))
        else:
            print "[Code %d]: %s - %s" % (errcode, errname, errmsg)
            reactor.stop()

    def _handleMessage(self, msg):
        print etree.tostring(msg)

    def initStomp(self):
        pass

    def execute(self):
        self.options, self.args = parse_args(self.parser, self.argv)
        self.buildHelp()
        self.executeRemote(str(self._execute()))

    def _execute(self):
        raise CommandFailed("please implement me")

    def executeFailed(self, exception):
        Command.executeFailed(self, exception)
        reactor.stop()

    def executeRemote(self, cmdstring):
        f = StompClientFactory(user='client')
        f.protocol = StompClientCmd
        f.cmd = self
        f.msg = cmdstring
        f.clientId = uuid()
        f.serverQueue = '/queue/xenbee.daemon'
        f.queue = '/queue/xenbee.client.%s' % (f.clientId,)
        reactor.connectTCP(self.options.host, self.options.port, f)
        reactor.run()
    
class Command_help(Command):
    """\
    help: Describe the usage of this program or its subcommands.

    usage: help [subcommand]
    Valid options:
         currently none
    """
    def __init__(self, argv):
        """initialize the 'help' command."""
        Command.__init__(self, argv)
        self.subcmd = createCommand(self.argv)
        
    def execute(self):
        if self.subcmd:
            print >>sys.stderr, dedent(self.subcmd.__doc__).strip()
        else:
            sb = [dedent(__doc__).strip()]
            sb.append("")
            sb.append("available subcommands:")
            sb.append("")
            for cls in globals().keys():
                if cls.startswith("Command_"):
                    sb.append("   "+cls.split("Command_")[1])
            print >>sys.stderr, "\n".join(sb)

class Command_create(RemoteCommand):
    """\
    create: Create a new instance.

    """

    def __init__(self, argv = []):
        """initialize the 'create' command."""
        RemoteCommand.__init__(self, argv)

        p = self.parser
        p.add_option("-k", "--kernel", dest="kernel",  type="string", help="the uri to the kernel")
        p.add_option("-r", "--initrd", dest="initrd",  type="string", help="the uri to a initrd")
        p.add_option("-m", "--mem",    dest="memory",  type="int",    help="the amount of memory to use (in MB)", default=128)
        p.add_option("-s", "--swap",   dest="swap",    type="int",    help="the amount of swap space to use (in MB)", default=128)
        p.add_option("-i", "--image",  dest="image",   type="string", help="the main image to boot")
        p.add_option("-C", "--cpus",   dest="cpus",    type="int",    help="the number of cpus to use", default=1)
        p.add_option("-j", "--jsdl",   dest="jsdl",    type="string", help="a jsdl document", default="-")
        p.add_option("-K", "--keep",   dest="keep_instance", action="store_true", help="a jsdl document", default=False)

    def _execute(self):
        # test for required values
        if not self.options.kernel:
            raise CommandFailed("'kernel' is required")
        if not self.options.image:
            raise CommandFailed("'image' is required")

        if self.options.jsdl == "-":
            # reading jsdl from stdin...
            print "reading stdin..."
            jsdlFile = sys.stdin
        else:
            jsdlFile = open(self.options.jsdl)
        jsdl = etree.parse(jsdlFile).getroot()
        

        # build xml message
        inst_def = etree.Element(xsdl.XSDL("InstanceDefinition"), nsmap={"xsdl": xsdl.XSDL_NS})
        inst_des = etree.SubElement(inst_def, xsdl.XSDL("InstanceDescription"))

        # add all files that have to be retrieved
        files = etree.SubElement(inst_des, xsdl.XSDL("Files"))

        fileMap = {}
        ctr = 1
        for uri in [self.options.kernel, self.options.initrd, self.options.image]:
            ref = "file-%d" % (ctr,)
            f_elem = etree.SubElement(files, xsdl.XSDL("File"))
            f_elem.attrib[xsdl.Tag("id")] = ref
            etree.SubElement(f_elem, xsdl.XSDL("URI")).text = uri

            fileMap[uri] = ref
            ctr += 1

        # startup parameters
        startup = etree.SubElement(inst_des, xsdl.XSDL("StartupParameters"))
        kernel = etree.SubElement(startup, xsdl.XSDL("Kernel"))
        kernel.attrib[xsdl.Tag("file-ref")] = fileMap[self.options.kernel]

        kernel = etree.SubElement(startup, xsdl.XSDL("Initrd"))
        kernel.attrib[xsdl.Tag("file-ref")] = fileMap[self.options.initrd]

        images = etree.SubElement(startup, xsdl.XSDL("Images"))
        for image in [self.options.image]:
            i_elem = etree.SubElement(images, xsdl.XSDL("Image"))
            i_elem.attrib[xsdl.Tag("file-ref")] = fileMap[image]

        # runtime parameter
        runtime = etree.SubElement(inst_des, xsdl.XSDL("RuntimeParameters"))
        if self.options.keep_instance:
            etree.SubElement(runtime, xsdl.XSDL("keep-running"))

        # move the jsdl:Application to the instance
        jsdl_job_desc = jsdl.find(xsdl.JSDL("JobDescription"))
        jsdl_app = jsdl_job_desc.find(xsdl.JSDL("Application"))
        
        jsdl_job_desc.remove(jsdl_app)
        inst_des.append(jsdl_app)

        # append the instance definition to the jsdl document's root
        jsdl.append(inst_def)
        
        return etree.tostring(jsdl)

class Command_kill(RemoteCommand):
    """\
    kill: Send a signal to an instance.

    """

    def __init__(self, argv):
        """initialize the 'kill' command."""
        RemoteCommand.__init__(self, argv)

        p = self.parser
        p.add_option("-s", "--signal", dest="signal",  type="int", default=15, help="the signal to use")

    def _execute(self):
        if not len(self.args):
            raise CommandFailed("at least one 'job-id' is required")

        msg = xsdl.XenBEEClientMessage()
        kill = msg.createElement("Kill", msg.root)
        msg.createElement("Signal", kill, self.options.signal)
        for job in self.args:
            # build xml message
            msg.createElement("JobID", kill, job)
        return msg

class Command_status(RemoteCommand):
    """\
    status: Request status information

    """

    def __init__(self, argv):
        """initialize the 'status' command."""
        RemoteCommand.__init__(self, argv)

        p = self.parser

    def _execute(self):
        msg = xsdl.XenBEEClientMessage()
        sreq = msg.createElement("StatusRequest", msg.root)
        msg.root.append(sreq)
        return msg

    def _handleMessage(self, slist):
        """handles the status message."""
        stats = []
        for child in slist:
            stats.append(self._parseStatus(child))

#        strftime("%a, %d %b %Y %H:%M:%S +0000", gmtime(task.startTime)))
        fmt = "%(ID)-36s %(IP)-15s %(User)-10s %(Submitted)-14s %(StartTime)-14s %(EndTime)-14s %(State)-10s %(ExitCode)s"
        hdr = { "ID": "TASK ID",
                "IP": "IP-ADDRESS",
                "User": "USER",
                "Submitted": "SUBMITTED",
                "StartTime": "STARTTIME",
                "EndTime": "ENDTIME",
                "State": "CUR.STATE",
                "ExitCode": "EXITCODE" }
        print fmt % hdr
        for s in stats:
            print fmt % s
        
    def _parseStatus(self, status_elem):
        s = {}
        for child in status_elem:
            s[xsdl.decodeTag(child.tag)[1]] = (child.text or "").strip()
        return s

Command_list = Command_status

class Command_showcache(RemoteCommand):
    """\
    showcache: lists all cached files

    """

    def __init__(self, argv):
        """initialize the 'showcache' command."""
        RemoteCommand.__init__(self, argv)
        p = self.parser

    def _execute(self):
        return xsdl.XenBEEListCache()

    def _handleMessage(self, msg):
        """handles the cache entries message."""
        fmt = "%-60s  %-10s %s"
        print fmt % (" URI", "DATA-TYPE", "DESCRIPTION")
        for entry in msg.findall(xsdl.XSDL("Entry")):
            uri = entry.findtext(xsdl.XSDL("URI"))
            type = entry.findtext(xsdl.XSDL("Type"))
            desc = entry.findtext(xsdl.XSDL("Description"))
            print fmt % (uri, type, desc)

class Command_submit(RemoteCommand):
    """\
    submit: Submit an xsdl document

    arguments:
       xsdl -- path to an xsdl document

    """

    def __init__(self, argv):
        """initialize the 'submit' command."""
        RemoteCommand.__init__(self, argv)

    def _execute(self):
        # submit the xsdl document
        if not len(self.args):
            raise CommandFailed("path to xsdl document required!")
        return open(self.args[0]).read()

def printShortHelp():
    print >>sys.stderr, "Type '%s help' for usage." % sys.argv[0]

def createCommand(argv):
    """Creates a command object from the given command line."""
    if len(argv):
        try:
            clsname = "Command_%s" % argv[0]
            if clsname in globals():
                cmd = globals()[clsname](argv)
                cmd.buildHelp()
                return cmd
            else:
                raise UnknownCommand(argv[0])
        except UnknownCommand, uc:
            print >>sys.stderr, "Unknown command: '%s'" % uc
            return None
        except:
            from traceback import format_exc
            print >>sys.stderr, "Unknwon error:", format_exc()
            return None
    else:
        return None

def connectFailed(e):
    print e
    reactor.stop()

class StompClientCmd(StompClient):

    def connectedReceived(self, frame):
        self.setReplyTo(self.factory.queue)
        self.subscribe(self.factory.queue, exclusive=True)
        self.send(self.factory.serverQueue, self.factory.msg)
        self.receive(time_out=self.factory.cmd.options.timeout).addCallback(self.message).addErrback(self.abort)

    def connectFailed(self, reason):
        print >>sys.stderr, "Connection to STOMP server failed!"
        self.factory.cmd.executeFailed(Exception(reason.msg))

    def message(self, msg):
        self.factory.cmd.handleMessage(msg)

    def abort(self, failure):
        if isinstance(failure.value, StompErrorReason):
            err = "%s [%d]" % (failure.value.msg, failure.value.errcode)
        else:
            err = failure.getErrorMessage()
        self.factory.cmd.executeFailed(err)

def main(argv):
    """The main routine."""
    sys.argv[0] = os.path.basename(sys.argv[0])

    cmd = createCommand(argv[1:])
    if cmd:
        try:
            cmd.execute()
            if cmd.failed[0]:
                raise CommandFailed(cmd.failed[1])
        except CommandFailed, cf:
            print >>sys.stderr, "%s:" % sys.argv[0], str(cmd), "failed (details follow)"
            print >>sys.stderr, "\n".join([ "%s: %s" % (sys.argv[0],s) for s in str(cf.message).split('\n')])
            return 2
        except:
            from traceback import format_exc
            print >>sys.stderr, "Error during command execution:", format_exc()
    else:
        printShortHelp()
        return 1


if __name__ == '__main__':
    sys.exit(main(sys.argv))
