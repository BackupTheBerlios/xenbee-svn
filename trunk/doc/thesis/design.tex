\setchapterpreamble[o]{%
  \dictum[Steve Jobs]{\textit{``Design is not  just what it looks like and
      feels like. Design is how it works.''}}}

\chapter{Design and Implementation}
\label{cha:design}

This chapter is about the design and implementation of the \emph{Xen-based
  Execution  Environment} (\gls{glo:XenBEE}).   The  execution environment
incorporates  a total  of three  main  components: the  \emph{xbe} on  the
user's side, the \emph{xbed} on  the server's side and the \emph{xbeinstd}
on  the  side of  a  single virtual  machine.   All  components have  been
implemented     using    the     \emph{Python}     programming    language
\cite{python-language}. In particular, version  $2.5$ of that language has
been used.

Some additional  modules and programs, that  are not part  of the standard
libraries shipped with Python, have been used, though. Among these are for
instance  the \texttt{twisted}  framework \cite{twisted-python}  which has
been  used  for  the  network  code,  a  library  called  \texttt{libvirt}
\cite{libvirt}  that  was used  to  connect  to  the Xen  virtual  machine
monitor, and a library that  provides Python bindings to the \texttt{curl}
library \cite{pycurl}.


\section{Overview}
\label{sec:design:overview}

The picture in Figure~\ref{fig:architecture-overview} shows an overview of
the three components which, when put together, make up the \emph{Xen-based
  Execution Environment} (\gls{glo:XenBEE}).

\begin{figure}[ht]
  \centering
  \includegraphics[scale=.7]{architecture-overview}
  \caption[Overview of the  \gls{glo:XenBEE} components]{The components of
    the Xen-based Execution Environment}
  \label{fig:architecture-overview}
\end{figure}

On the left hand side of the picture are the users using the \emph{xbe} to
communicate with the execution  environment. The \emph{xbe} refers in this
case  to the command  line tool  which I  have implemented  as a  proof of
concept  to interact  with the  \emph{xbed}.  The  interface that  an user
utilizes to execute his applications  with the \gls{glo:XenBEE} could be a
web-portal or some other tool with a graphical user interface, as well.

\medskip

On the right hand side are the components that are required to execute the
applications within  virtual machines.  The \emph{xbed} has  to be running
on a machine, that supports  the Xen hypervisor.  It maintains an internal
connection to  a local  cache, which can  be used  by any user  to deposit
arbitrary data on the  server side.  The \emph{xbed} uses \texttt{libvirt}
to connect to the Xen hypervisor and to manage active virtual machines.

Each virtual machine  must provide the \emph{xbeinstd}, that  means it has
to be started at some point during the initialization process of the guest
operating system. Any image that is submitted to the execution environment
must therefore  contain this  program. The \emph{xbeinstd}  is responsible
for two  major issues:  executing the actual  application and  keeping the
virtual machine instance alive.   Execution of an application involves for
instance  passing  arguments  to   the  executable,  setting  the  working
directory and redirecting the input and output streams. The \emph{xbed} is
going  to shut  stale virtual  machines down,  unless  the \emph{xbeinstd}
sends  regular keep-alive  messages  to the  \emph{xbed}.   If the  user's
application has finished, the \emph{xbeinstd} signals the \emph{xbed} that
the virtual machine is ready to be shut down.

\medskip

The  thicker connections  between \emph{xbe}  and \emph{xbed}  as  well as
between \emph{xbed}  and \emph{xbeinstd} are  logical connections realized
by using message-queues and one  or more \gls{glo:MQS} in between. Whereas
he  thinner links  are either  inner-process connections  (in case  of the
cache) or  connections between  parent and child  process (in case  of the
user-application).

\section[Xen-based Execution Daemon]{Xen-based Execution Daemon (xbed)}
\label{sec:xbed}

This  section describes  the  ``heart'' of  the  \gls{glo:XenBEE} ---  the
\emph{xbed}.  Well, the \emph{xbed}  is itself composed of several smaller
components that  are each responsible for  a single detail  of the daemon.
The    main    components    though    are   the    \texttt{Cache},    the
\texttt{TaskManager}  and the  \texttt{InstanceManager}. The  former  is a
rather simple implementation of a local data cache, that will be discussed
in a later section.

\begin{figure}[ht]
  \centering
  \includegraphics[scale=.55]{xbed-architecture}
  \caption[Components of the xbed]{The most important components of the xbed}
  \label{fig:xbed-architecture}
\end{figure}

\subsubsection{Network Layer}

On startup, the  daemon tries to connect to  the message-queue server that
has been  defined either in  its configuration file  or as a  command line
parameter. This process  is realized by the \emph{network  layer}. It uses
the  \texttt{twisted} framework to  establish a  \gls{glo:TCP} connection.
When the connection has been successfully established, a special transport
protocol --- the  STOMP protocol --- is attached  to the connection. STOMP
is  the \emph{Streaming  Text Oriented  Messaging Protocol}  and basically
defines a  very simple protocol to  send and receive text  messages over a
message-queue server.  On top of  this text message based protocol are XML
based  protocols  that  accomplish  the whole  communication  between  all
components.   There is currently  a basic  XML protocol  that encapsulates
single ``messages'', consisting just of header and body, and two protocols
that  connect up  the \emph{xbe}  and the  \emph{xbeinst}  accordingly.  A
special  protocol providing  security  related services  (\ie privacy  and
validity) can be added as an additional layer.

Anyway, the  details of the \gls{glo:STOMP}  and XML protocols  as well as
the network layer,  which is to some extent equal  among all components of
the        \gls{glo:XenBEE},       will       be        discussed       in
Section~\ref{sec:communication-protocol},
\emph{\nameref{sec:communication-protocol}}.

\subsubsection{Task-Manager}

When an  user submits,  terminates or  requests the status  of one  of her
jobs, the  message is actually handled by  the \texttt{TaskManager}.  This
component controls all tasks, the system knows of. A ``task'' does in this
case  not refer  to the  actual application  an user  submitted, but  to a
container that holds the task's  state machine, description and probably a
reference to the virtual machine instance used for this task.

A new task gets initialized every  time an user requests a reservation. At
this time it contains nothing more  than the state machine which is in its
start-state                               (\ie \texttt{Pending:Reserved}).
Section~\ref{sec:xbed:job-model}  discusses   the  implementation  of  the
job-model that has been used to  represent an activity.

Each task and each reservation has its own unique identifier by which they
are known  to the system  and to the  user.  Those unique  identifiers are
implemented     by    using     \emph{Universal     Unique    Identifiers}
(\gls{glo:UUID}s).  Whereas  the task identifier is more  or less publicly
available\footnote{a listing  of all current tasks comparable  to the UNIX
  \texttt{ps}  command could be  possible}, the  identifier of  the user's
reservation is  only known to  that particular user (or  some intermediary
software such as  a Calana-agent). All requests that an  user makes to the
system,  that refer  to a  reservation and  hence to  a task,  require the
reservation's unique identifier.

When an user confirms a reservation,  he also sends the job description as
a \gls{glo:JSDL}  document along with the confirmation  message.  The task
is  thus completely  specified and  may  perform the  transition into  the
\texttt{Executing} state. To this time, the task-manager creates a special
spool directory  for that  task which is  eventually going to  contain all
necessary  files to  create the  virtual  machine and  execute the  user's
application. The  details of how the  required files are  obtained will be
discussed  in   a  later  section  (Section~\ref{sec:xbed:data-transfer}).
After  all   files  have  been   retrieved,  the  \texttt{InstanceManager}
component is used to create a new virtual machine for the task.

\subsubsection{Instance-Manager}

The instance-manager's purpose is  to create, control, monitor and destroy
active virtual  machine instances.  Again  unique identifiers are  used to
name the  virtual machines. To start  a virtual machine  several files are
required:  an   operating  system  installation  residing   in  a  special
file-system  \gls{glo:image} file, a  \gls{glo:kernel} and  potentially an
initial ramdisk  image (initrd),  that contains additional  device drivers
and setup  routines that  are not directly  included in the  kernel. Those
files must  be provided by  the user,  since he is  the one who  knows his
application and how the operating  system has to be configured to actually
execute the application.

Well, by just using these three files, a virtual machine cannot be created
right away,  it must be  \emph{configured} first.  The configuration  of a
virtual  machine is manifold,  it contains  descriptions of  the operating
system  which  shall be  used  (\ie the  mentioned  three files),  memory
settings (\ie the amount of  virtualized physical memory), them number of
virtual CPUs and network parameters.

\subparagraph{Instance Configuration and Setup}

The \emph{xbed}  provides the possibility to  use different virtualization
back-ends,  but  the  current  implementation supports  only  Xen  virtual
machines. It could, for instance, be possible to implement a back-end that
uses VMWare's  \cite{vmware} virtual machines, even no  virtual machine at
all could be thinkable.

The back-end uses  the \texttt{libvirt} \gls{glo:API} to connect
to  the Xen hypervisor.  This connection  is basically  used to  query the
current state of  a virtual machine and to shut  a running virtual machine
down.   Virtual machine creation  is implemented  by using  a call  to the
\texttt{xm} command line tool provided by the Xen user-space tools.  Prior
a  new  instance   can  be  created,  a  configuration   file  has  to  be
generated. This configuration file contains the mentioned parameters.

The  network  configuration   of  a  virtual  machine  is   based  on  the
\emph{Dynamic Host Configuration  Protocol} (\gls{glo:DHCP}).  That means,
the guest  \gls{glo:OS} has  to be configured  to use  \gls{glo:DHCP}. The
administrator of  the host, on which  the \emph{xbed} runs,  can specify a
list  of  \gls{glo:MAC}  addresses  that  shall be  used  by  the  virtual
machines.

Virtualized  physical  memory  and  the  number of  virtual  CPUs  can  be
specified  in the  \gls{glo:JSDL} document  using the  predefined resource
descriptions.

\subparagraph{Instance Creation}

The next step is the generation  of a configuration file which can be used
by the back-end --- in this case  Xen --- to set up a new virtual machine.
The task's  state machine  is triggered  to change its  state to  the next
sub-state   of  \texttt{Running}:  \texttt{InstanceStarting}.    Once  the
virtual machine has  been created, the \emph{xbed} awaits  a callback from
the virtual machine.  This scallback expresses itself in form of a message
sent  by  the \emph{xbeinstd}  running  within  the  just created  virtual
machine.  If  this signal does  not get sent  within a given  timeout, the
virtual  machine instance  is assumed  to  be broken  and is  going to  be
destroyed, resulting in a failed  execution of the user's task, of course.
This callback fulfills two important functions --- it makes sure, that the
virtual machine's  network configuration is correct  and fully functional,
and  that the  \emph{xbeinstd}  did start  properly  --- thus,  improperly
configured images are recognized very fast.  Now, that the virtual machine
is ready to execute the  user's application, the task's description may be
sent to  the \emph{xbeinstd} and  the task's state machine  may eventually
change  its state  to  \texttt{Executing}. The  details  of executing  the
application is going to be discussed in Section~\ref{sec:xbeinstd}.

After  finishing the  execution  of the  user's  application, the  virtual
machine will  be shut down and the  result can be staged  out according to
the specified \gls{glo:JSDL} document.

\bigskip

The next sections  describe the implementation of the  used job-model, how
the staging  of input  and output data  is performed  and how an  user can
benefit from using the provided data-cache.

\subsection{Job-model Implementation}
\label{sec:xbed:job-model}

In     the     sections    \emph{`\nameref{sec:fundamentals:bes}'}     and
\emph{`\nameref{sec:calana-support}'}               on               pages
\pageref{sec:fundamentals:bes}       and      \pageref{sec:calana-support}
respectively, I have already discussed the usage of the job-model that has
been  proposed  by the  \gls{glo:OGSA}-\gls{glo:BES}  working group.   The
Calana  architecture   requires  the  model  to   contain  extensions  for
\emph{reservation} and \emph{data staging}.

To model  the process of starting  a virtual machine, I  have extended the
model  again  to provide  an  additional state  \texttt{Instance-Starting}
which  is a  sub-state  of  the basic  state  \texttt{Running}. The  final
job-model is shown in Figure~\ref{fig:bes-job-model}.

\begin{figure}[ht]
  \centering
  \includegraphics[scale=.55]{bes-job-model}
  \caption{The job-model used in the \gls{glo:XenBEE}}
  \label{fig:bes-job-model}
\end{figure}

The  implementation of  this model  builds up  on an  implementation  of a
\emph{Finite State  Machine} (\gls{glo:FSM}).  The  \texttt{Task} class, I
mentioned  earlier,  contains  a  reference  to an  instance  of  such  an
\gls{glo:FSM}. Each time  a state change is desired,  the \gls{glo:FSM} is
called with  an ``input'' signal. The \gls{glo:FSM}  then calls registered
functions that  implement the transition's  behavior. If, for  example, an
user wants to terminate his  activity, the \gls{glo:FSM} is presented with
a ``terminate-token''. The FSM  calls then specialized functions that deal
with the termination  request according to the current  state. That means,
distinct   functions    are   perhaps   called    when   traversing   from
\texttt{Pending:Reserved}    and    \texttt{Running:Executing}   to    the
\texttt{Terminated} state, respectively.

Some of the transitions  involve rather complex and time-consuming actions
(\eg file  transfers).   Those  complex  transitions are  represented  by
\emph{activity-objects}.    An   activity-object   is  an   object,   that
encapsulates  some behavior  along  with  a state  ---  commonly known  as
\emph{Function}-objects or \emph{Functors}.  I named them activity-objects
on  purpose, because they  are usually  executed by  a separate  thread of
control  in concurrency  to other  activities within  the  system. Another
reason for  encapsulating some of  the transitions in  activity-objects is
the possible intervention by an user.

The BES  model allows an  user to terminate  his activity at any  time. In
particular that means,  that any action belonging to  that activity, which
currently takes place  on the server, has to be  stopped or aborted.

Since the task-manager does not only create, but also manage the tasks, he
is responsible for stopping current activities of a task if he is asked to
do so.  For that reason, he is  in charge of a per task list that contains
all current activities  for that task. If the task-manage  is now going to
handle a request for termination of one of the tasks, he first cancels all
registered activity-objects before letting the task to change its state to
\texttt{Terminated}.

\begin{figure}[ht]
  \centering
  \includegraphics[scale=.55]{activity-queue}
  \caption{Handling of \emph{activity-objects} with an activity-queue.}
  \label{fig:activity-queue}
\end{figure}

The picture in Figure~\ref{fig:activity-queue} shows such an occasion. The
task (represented by  the blue box) is currently  in the \texttt{Stage-In}
sub-state  of \texttt{Running}  and is  awaiting the  availability  of its
required  files.  The  activity  which represents  here  the operation  of
staging files in is shown as  the encircled lightning bolt.  When the task
transitions  into  the \texttt{Stage-In}  state,  it  registers the  shown
activity with  the task-manager. The task-manager  in turn adds  it to his
queue of current activities (shown as the reddish tube in the right of the
picture).  When  the activity is  finished (figuratively speaking:  if the
activity exits through  the bottom of the tube), the  task may advance its
state to \texttt{Instance-Starting}, \ie it  can be attempted to start an
instance for this task.

Since  the  retrieval of  files  from  different  locations (specified  by
\gls{glo:URI}s  in the \gls{glo:JSDL})  may take  some time,  this example
also motivates  the usage of threads  to decouple other  activities of the
system  from these  steps. When  terminating  an activity,  the thread  is
signalled to abort whatever it is doing at the time.

\bigskip

Well,  the  whole cycle  through  which  a task  may  run  is depicted  in
Figure~\ref{fig:act-execute-task}  as  an   activity  diagram.   The  only
sub-activity that  cannot be aborted  at all is the  \emph{stop instance}
operation. That is because the  shutdown process of the underlying virtual
machine just cannot be cancelled or  reversed. That is also the reason to
not having an extra sub-state for that operation in the job-model.

The  process starts  with waiting  on  a ``ready-to-go''  signal, that  is
usually included  directly in the \texttt{Confirm} message  received by an
user,  but  can  also  be  given  in  a  subsequent  message  on  its  own
(\texttt{Start\-Activity})\footnote{the  communication  protocol  and  the
  messages           involved          are           discussed          in
  Section~\ref{sec:communication-protocol},
  \emph{\nameref{sec:communication-protocol}}.}.  The  next steps resemble
the previously discussed job-model. Of course, any of those activities may
\emph{fail}, which effectively  results in the failing of  the whole task.
The operations that are involved  when one of the sub-activities fails are
the  same  as  for  the  abortion of  that  sub-activity.   Actually,  the
\emph{stop  instance}  operation  cannot  fail  either,  since  it  always
possible to forcibly shut a virtual machine down.

\begin{figure}[ht]
  \centering
  \includegraphics[scale=.55]{act-execute-task}
  \caption[Summary of executing a task]{Summary of the steps involved when executing a task.}
  \label{fig:act-execute-task}
\end{figure}

The \emph{start  instance} operation differs from the  other operations in
that two components are involved, the \emph{xbed} and the \emph{xbeinstd}.
The \emph{xbed}  first attempts  to start a  back-end instance (\eg  a Xen
virtual machine) and waits for the instance to be started, eventually.

After the instance  has been started, \ie the back-end  did not reject the
provided  configuration, the  \emph{xbed}, actually  the  thread executing
this  particular  activity,  waits  for  the \emph{xbeinstd}  to  send  an
\texttt{Instance\-Available}        message       back        to       the
\emph{xbed}. Figure~\ref{fig:act-start-instance} shows the details of that
particular activity.

\begin{figure}[ht]
  \centering
  \includegraphics[scale=.55]{act-start-instance}
  \caption[Start Instance Activity]{The  \emph{xbed} waits for the virtual
    machine to  be available.   The availability of  a virtual  machine is
    made sure by waiting on a special message from the \emph{xbeinstd}.}
  \label{fig:act-start-instance}
\end{figure}


As you can see, there are  three different outcomes for this activity. The
instance can  be flagged as  available, which renders the  task eventually
executable,  or  the  activity  can  be  aborted  due  to  a  request  for
termination by the user or the instance can fail to start at all.


\subsection{Data Transfer Handling}
\label{sec:xbed:data-transfer}

\begin{itemize}
\item uri (http,ftp,etc)
\item cache references
\item failure
\item validation (hashes)
\item compression (gzip, bzip, tar.*)
\item user interaction --- terminate
\item upload
\end{itemize}

\begin{figure}[ht]
  \centering
  \includegraphics[scale=.55]{act-retrieve-file}
  \caption[File Retrieval Activity]{TODO: fill me in}
  \label{fig:act-retrieve-file}
\end{figure}


\begin{figure}[ht]
  \includegraphics[scale=.55]{act-stage-in}
  \caption[Stage-In Activity]{TODO: fill me in}
  \label{fig:act-stage-in}
\end{figure}


\subsection{Caching Of Arbitrary Files}
\label{sec:caching}

\begin{itemize}
\item addToCache
\item uri based retrieval
\item uuid as cache entry id
\item referencing to entries
\item description for cached data
\item data types (image, kernel, initrd, data)
\item database
\end{itemize}

\subsubsection{Adding data to the cache}

\subsubsection{Discovering cache entries}

\begin{figure}[ht]
  \centering
  \includegraphics[scale=.75]{msc-list-cache}
  \caption[MSC List Cache Entries]{TODO: fill me in}
  \label{fig:msc-list-cache}
\end{figure}

\subsubsection{Using cache entries}

\section[Xen-based Execution Instance Daemon]{Xen-based Execution Instance Daemon (xbeinstd)}
\label{sec:xbeinstd}

\begin{itemize}
\item notifies xbed when instance is up (\ie network connectivity)
\item keep-alive
\item input files are already available
\item parses jsdl
\item sets working directory
\item redirects standard input/output/error to the files in jsdl (or /dev/null)
\item starts task when the xbed notifies
\item passes arguments specified in jsdl
\item notifies xbed when application has finished (shutdown may be initialized)
\end{itemize}
foo bar

\section{The Communication Protocol}
\label{sec:communication-protocol}

\begin{itemize}
\item make reservation
\item confirm reservation (jsdl) +/- start
\item submit whole job (make res + confirm)
\item terminate activity
\item status request
\item add cache entry
\item security establishment (certificates, encryption, signing)
\item stomp
\end{itemize}

\subsection{STOMP}
\label{sec:protocol:stomp}

\subsection{MSCs}

\begin{figure}[ht]
  \centering
  \includegraphics[scale=.75]{msc-reserve}
  \caption[MSC Make Reservation]{TODO: fill me in}
  \label{fig:msc-reserve}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[scale=.75]{msc-confirm}
  \caption[MSC Confirm Reservation]{TODO: fill me in}
  \label{fig:msc-confirm}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[scale=.75]{msc-status-request}
  \caption[MSC Request Task Status]{TODO: fill me in}
  \label{fig:msc-status-request}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[scale=.75]{msc-terminate}
  \caption[MSC Terminate Task Request]{TODO: fill me in}
  \label{fig:msc-terminate}
\end{figure}

\subsection{Network Topology}
\label{sec:network-topology}

\begin{itemize}
\item simple topology: just one mqs (preferably on the xbed-host)
\item advanced topology: many mqs with configured forwarding
\item avoids common problems that arise with NAT and firewall policies
\item xbeinstd and possibly the application use the same mqs as the xbed
\end{itemize}

\begin{figure}[ht]
  \centering
  \includegraphics[scale=.75]{simple-network-topology}
  \caption[Network  Topology   (simple)]{The  simplest  network  topology,
    consisting of  only one Message  Queue Server and  three communication
    partners.}
  \label{fig:simple-net-top}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[scale=.75]{network-topology}
  \caption[Network  Topology]{TODO: fill me in}
  \label{fig:net-top}
\end{figure}

\subsection{Security}
\label{sec:security}

\begin{itemize}
\item symmetric encryption one-time key
\item signing of whole message
\item encryption of body
\item xml-message-security
\end{itemize}

\begin{figure}[ht]
  \centering
  \includegraphics[scale=.75]{msc-establish-mls}
  \caption[MSC Message Layer Security]{TODO: fill me in}
  \label{fig:msc-establish-mls}
\end{figure}


\begin{figure}[ht]
  \centering
  \includegraphics[scale=.75]{message-layer-security}
  \caption[Message Layer Security]{TODO: fill me in}
  \label{fig:net-mls}
\end{figure}

\subsubsection{m2crypto / openssl}

\begin{itemize}
\item problems with m2crypto on 64bit architecture
\item both are currently incompatible to each other
\item both sides (client/server) have to use the same --- either m2 or
  direct openssl
\end{itemize}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 
